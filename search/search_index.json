{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Document/","text":"Welcome to Kubernetes Lab Setup As part of my training material I have a need to setup Kubernetes infrastructure quickly. As this is a learning platform there is a need to destroy and rebuild multiple times. This repository is for my documentation on the setup steps. The information is provided such that one can replicate this same setup easily. Here are some high level on the Kubernetes Lab setup. the Infrastructure is setup on HyperV, there is little information available for Hyper V environments . It took quite an effort to test , verify and document the stesp. The Kubernetes setup is for a single node and a High Availability setup. The Lightweight Kubernetes is deployed. Lightweight Kubernetes The Virtual Machines are setup with Ubuntu 20.04. Alpine Virtual Machine is used for the management and Loadbalancer Virtual Machines.","title":"Index"},{"location":"Document/#welcome-to-kubernetes-lab-setup","text":"As part of my training material I have a need to setup Kubernetes infrastructure quickly. As this is a learning platform there is a need to destroy and rebuild multiple times. This repository is for my documentation on the setup steps. The information is provided such that one can replicate this same setup easily. Here are some high level on the Kubernetes Lab setup. the Infrastructure is setup on HyperV, there is little information available for Hyper V environments . It took quite an effort to test , verify and document the stesp. The Kubernetes setup is for a single node and a High Availability setup. The Lightweight Kubernetes is deployed. Lightweight Kubernetes The Virtual Machines are setup with Ubuntu 20.04. Alpine Virtual Machine is used for the management and Loadbalancer Virtual Machines.","title":"Welcome to Kubernetes Lab Setup"},{"location":"Document/scratch/","text":"nfs for ubuntu vi /etc/exports /srv/fai/ubuntu 192.168.33.250/24(async,ro,no_subtree_check) mount -r ~/Downloads/ubuntu-22.10-live-server-amd64.iso /mnt vi /etc/ssh/sshd_config fix up down arrow in vi ~/.vimrc set nocompatible user-data by mac-address https://askubuntu.com/questions/1290624/fetch-autoinstall-based-on-mac keyboard: layout: us toggle: null variant: '' early-commands: - curl -G -o /autoinstall.yaml http://192.168.100.1/autoinstall/user-data -d \"mac=$(ip a | grep ether | cut -d ' ' -f6)\" https://askubuntu.com/questions/1309505/choose-autoinstall-config-by-bios-serial-or-mac extract user-data based on mac addrress to update autoinstall.yaml. This way each VM can have its own configuration. early-commands: - cp \"/cdrom/nocloud/install-configs/$(dmidecode -s system-serial-number)\" /autoinstall.yaml","title":"nfs for ubuntu"},{"location":"Document/scratch/#nfs-for-ubuntu","text":"vi /etc/exports /srv/fai/ubuntu 192.168.33.250/24(async,ro,no_subtree_check)","title":"nfs for ubuntu"},{"location":"Document/scratch/#_1","text":"mount -r ~/Downloads/ubuntu-22.10-live-server-amd64.iso /mnt","title":""},{"location":"Document/scratch/#_2","text":"vi /etc/ssh/sshd_config","title":""},{"location":"Document/scratch/#fix-up-down-arrow-in-vi","text":"~/.vimrc set nocompatible","title":"fix up down arrow in vi"},{"location":"Document/scratch/#_3","text":"user-data by mac-address https://askubuntu.com/questions/1290624/fetch-autoinstall-based-on-mac keyboard: layout: us toggle: null variant: '' early-commands: - curl -G -o /autoinstall.yaml http://192.168.100.1/autoinstall/user-data -d \"mac=$(ip a | grep ether | cut -d ' ' -f6)\" https://askubuntu.com/questions/1309505/choose-autoinstall-config-by-bios-serial-or-mac extract user-data based on mac addrress to update autoinstall.yaml. This way each VM can have its own configuration. early-commands: - cp \"/cdrom/nocloud/install-configs/$(dmidecode -s system-serial-number)\" /autoinstall.yaml","title":""},{"location":"Document/Introduction/000-ReadMeFirst/","text":"Readme First","title":"000 ReadMeFirst"},{"location":"Document/Introduction/000-ReadMeFirst/#readme-first","text":"","title":"Readme First"},{"location":"Document/Introduction/001-High-Level-node-setup/","text":"Kubernetes lab setup - High level reference. hostname IP address alpine1 192.168.100.1/24 Hyper-V-Host 192.168.100.2/24 xsinglenode 192.168.100.199/24 loadbalancer 192.168.100.201/24 master1 192.168.100.202/24 master2 192.168.100.203/24 master3 192.168.100.204/24 worker1 192.168.100.205/24 worker2 192.168.100.206/24 worker3 192.168.100.207/24 metallb 192.168.100.208-215 alpine1 functions for the devices in the subnet 192.168.100.0/24 as - DHCP server - Internet Router This server has 2 NIC one for the Internet access and another on the subnet 192.168.100.0/24 - DNS - NGINX web server - (removed)NFS server - TFTP server - Hosting the various files required for the Ubuntu and Kubernetese setup xsinglenode Is a single node implementation of Kubernetes. loadbalancer functions as the entry point to the Master nodes, performing the High Availability fucntions for the multiple Master nodes. master1/2/3 This is the Kubernetes Control plane. Acting as a High Availability setup that allows for 1 Master node failure at any time. worker1/2/3 The Kubernetes workloads are deployed on these nodes. 3 nodes allow for some load balancing in the event nodes need to be taken down for maintenance purposes. metallb The Ingress requires a set of IP addresses to cater for incoming traffic to the Kubernetes cluster. These IP ranges are reserved for this functionality. High Level Network Diagram HYPER-V Network connectivity All the VM's will use alpine1 as the gateway to the internet. Apart from the gateway function, alpine1 also acts as performs several other functions. flowchart TD subgraph HYPER-V Network connectivity Internet o--o newLines[\"`alpine1 DHCP Router DNS NGINX NFS TFTP`\"] newLines[\"`**alpine1** DHCP Router DNS NGINX NFS TFTP`\"] o--o alpine1 alpine1 o--o xsinglenode; alpine1 o--o loadbalancer; alpine1 o--o master1; alpine1 o--o master2; alpine1 o--o master3; alpine1 o--o worker1; alpine1 o--o worker2; alpine1-->worker3; end","title":"Kubernetes lab setup - High level reference."},{"location":"Document/Introduction/001-High-Level-node-setup/#kubernetes-lab-setup-high-level-reference","text":"hostname IP address alpine1 192.168.100.1/24 Hyper-V-Host 192.168.100.2/24 xsinglenode 192.168.100.199/24 loadbalancer 192.168.100.201/24 master1 192.168.100.202/24 master2 192.168.100.203/24 master3 192.168.100.204/24 worker1 192.168.100.205/24 worker2 192.168.100.206/24 worker3 192.168.100.207/24 metallb 192.168.100.208-215 alpine1 functions for the devices in the subnet 192.168.100.0/24 as - DHCP server - Internet Router This server has 2 NIC one for the Internet access and another on the subnet 192.168.100.0/24 - DNS - NGINX web server - (removed)NFS server - TFTP server - Hosting the various files required for the Ubuntu and Kubernetese setup xsinglenode Is a single node implementation of Kubernetes. loadbalancer functions as the entry point to the Master nodes, performing the High Availability fucntions for the multiple Master nodes. master1/2/3 This is the Kubernetes Control plane. Acting as a High Availability setup that allows for 1 Master node failure at any time. worker1/2/3 The Kubernetes workloads are deployed on these nodes. 3 nodes allow for some load balancing in the event nodes need to be taken down for maintenance purposes. metallb The Ingress requires a set of IP addresses to cater for incoming traffic to the Kubernetes cluster. These IP ranges are reserved for this functionality.","title":"Kubernetes lab setup - High level reference."},{"location":"Document/Introduction/001-High-Level-node-setup/#high-level-network-diagram","text":"HYPER-V Network connectivity All the VM's will use alpine1 as the gateway to the internet. Apart from the gateway function, alpine1 also acts as performs several other functions. flowchart TD subgraph HYPER-V Network connectivity Internet o--o newLines[\"`alpine1 DHCP Router DNS NGINX NFS TFTP`\"] newLines[\"`**alpine1** DHCP Router DNS NGINX NFS TFTP`\"] o--o alpine1 alpine1 o--o xsinglenode; alpine1 o--o loadbalancer; alpine1 o--o master1; alpine1 o--o master2; alpine1 o--o master3; alpine1 o--o worker1; alpine1 o--o worker2; alpine1-->worker3; end","title":"High Level Network Diagram"},{"location":"Document/Introduction/001-Hyper-V-Host-Specification/","text":"Hyper-V-Host-Specification In this Lab setup The Hyper V host server specifications are as follows Interl i7-8700 3.2GHz CPU 32GB of Memory At least 1 Terabytes of Hard Disk As a reference with all the Virtual Machines Running the following was the utilization 1. CPU <50% utilization 2. Memory ~ 64% This is to provide a perspective on the Host CPU specifications for your Lab setup.","title":"Hyper-V-Host-Specification"},{"location":"Document/Introduction/001-Hyper-V-Host-Specification/#hyper-v-host-specification","text":"In this Lab setup The Hyper V host server specifications are as follows Interl i7-8700 3.2GHz CPU 32GB of Memory At least 1 Terabytes of Hard Disk As a reference with all the Virtual Machines Running the following was the utilization 1. CPU <50% utilization 2. Memory ~ 64% This is to provide a perspective on the Host CPU specifications for your Lab setup.","title":"Hyper-V-Host-Specification"},{"location":"Document/Introduction/001-Hyper-V-VM-creation/","text":"Hyper-V Virtual Machine Powershell script As part of a Lab setup, I expect to create and destroy the VM's regularly. To reduce the pain of recreating manually, I use a Powershell script to create the Hyper-V VM's with certain specifications. To use this script, you must have already have a working Hyper-V. You can refer to this link Enable Hyper-V on Windows 11 To use this script:- - run Powershell ISE as admin. - Save a file to a working folder with the content below. - The script uses the f:\\ drive you may want to change it to match the drive you have. - You also need to create a file 001-Kubernetes-Create-HyperV-VM-v1.1.csv with the content stated in the script. This will be the source for the VM's to be created. - Once the file is saved click on the Green Play button, this will execute the script. // method to access Video-- QR code? Here is a video that might help # create working folder # this script will default to F:\\kubernetes-project-lab # Change the Drive letter to on that exists on your computer, Set-ExecutionPolicy -ExecutionPolicy RemoteSigned <# example content of \"vms.csv\" You can change the VM name VMName,NetworkSwitch1,NetworkSwitch2,DiskSizeGB1,DiskSizeGB2,CPUCount,MemoryGB,ISOPath,BootOrder alpine1,Internet,\"Private 192.168.100.0/24\",50,,1,1,alpine-standard-3.18.4-x86_64.iso,DVD loadbalancer,,\"Private 192.168.100.0/24\",50,,1,1,alpine-standard-3.18.4-x86_64.iso,Network master1,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network master1,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network master2,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network master3,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network worker1,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network worker2,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network worker3,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network xsinglenode,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network ## NetworkSwitch1 : this is the internet connection NetworkSwitch2 : this is the private network \"Private 192.168.100.0/24\" ISOPath : if there is a DVD loaded the iso name is listed here. BootOrder : DVD > First Boot DVD, Second Boot HDD Network > First Boot Network \"Private 192.168.100.0/24\" , Second Boot HDD #> # Get the directory containing the script $scriptDirectory = Split-Path -Parent $MyInvocation.MyCommand.Path # Set the path to the CSV file $csvPath = \"$scriptDirectory\\vms.csv\" # Read the CSV file $vms = Import-Csv -Path $csvPath # create working folder #this is where the Hyper-V files will be created. # this script will default to F:\\kubernetes-project-lab $workingfolder = \"F:\\kubernetes-project-lab\" if (!(Test-Path -Path \"$workingfolder\" -PathType Container)) { New-Item -Path \"$workingfolder\" -ItemType Directory } ### Download the ISO images to the folder listed here. $isofolder = \"$workingfolder\\iso\\\" if (!(Test-Path -Path \"$isofolder\" -PathType Container)) { New-Item -Path \"$isofolder\" -ItemType Directory } ## Download alpine iso $outputPath = $DVDalpine $url = \"https://dl-cdn.alpinelinux.org/alpine/v3.18/releases/x86_64/alpine-standard-3.18.4-x86_64.iso\" $DVDalpine=Join-Path $isofolder (Split-Path $url -Leaf) # extracts filename from downloadurl # download if file does not already exist if (!(Test-Path -Path \"$DVDalpine\")) { Invoke-WebRequest -Uri $url -OutFile $outputPath } ## Download Ubunto iso $outputPath = $DVDUBUNTU $url = \"https://releases.ubuntu.com/focal/ubuntu-20.04.6-live-server-amd64.iso\" $DVDUBUNTU = Join-Path $isofolder (Split-Path $url -Leaf) # extracts filename from download # download if file does not already exist if (!(Test-Path -Path \"$DVDUBUNTU\")) { Invoke-WebRequest -Uri $url -OutFile $outputPath } ## change the name to the switch that has access to the internet. ## Hyper-V > Virtual Switch Manager > Identify the Switch names $switchInternet=\"internet\" ## this subnet is used for this example this is a label so any other subnet can be used for the VM's. $switchprivate=\"Private 192.168.100.0/24\" ## ### Creates new private network. $existingSwitch = Get-VMSwitch -Name $switchprivate -SwitchType Internal -ErrorAction SilentlyContinue if ($existingSwitch.name -eq $null) { New-VMSwitch -Name $switchprivate -SwitchType Internal -Notes \"created for k8s-lab project \" } else { Write-Host \"The switch '$switchprivate' already exists.\" } # VM creation begins here. foreach ($vm in $vms) { $vmfolder = \"$workingfolder\\VirtualMachines\\$($vm.VMName)\" # Intialize variable typess to enable provisioning of Hyper-V VM. [int64]$RAM=$null [int64]$RAMmax=$null [System.UInt64]$Disksize1=$null [System.UInt64]$Disksize2=$null # VM CPU and Memory config New-VM -Name $vm.VMName -Generation 2 -Path $vmfolder $RAM = (1GB * $vm.MemoryGB) $RAMmax=(2GB * $vm.MemoryGB) set-VM -Name $vm.VMName -MemoryStartupBytes $RAM Set-VM -VMName $vm.VMName -ProcessorCount $vm.CPUCount # -DynamicMemory -MemoryMaximumBytes $RAMmax -MemoryStartupBytes $RAM # Hard disk Primary OS [System.UInt64]$Disksize1=([long]$vm.DiskSizeGB1 * 1GB) [System.UInt64]$Disksize2=([long]$vm.DiskSizeGB2 * 1GB) $diskPath1 = Join-Path $vmfolder \"$($vm.VMName)-hdd1.vhdx\" New-VHD -Path $diskPath1 -SizeBytes $Disksize1 -Dynamic Add-VMHardDiskDrive -VMName $vm.VMName -Path $diskPath1 -ControllerType SCSI -ControllerLocation 0 # Additional Hard disk if ($vm.DiskSizeGB2 -ne \"\") { $diskPath2 = Join-Path $vmfolder \"$($vm.VMName)-hdd2.vhdx\" New-VHD -Path $diskPath2 -SizeBytes $Disksize2 -Dynamic Add-VMHardDiskDrive -VMName $vm.VMName -Path $diskPath2 -ControllerType SCSI -ControllerLocation 1 } else { \"Disk2 not required\" } # Load ISO drive for installation $isoPath = Join-Path \"$workingfolder\\iso\" $($vm.ISOPath) add-VMDvdDrive -VMName $vm.VMName -Path $isoPath -ControllerLocation 3 #Network adapters if($vm.NetworkSwitch1 -ne \"\") { add-VMNetworkAdapter -VMName $vm.VMName -SwitchName $vm.NetworkSwitch1 add-VMNetworkAdapter -VMName $vm.VMName -SwitchName $vm.NetworkSwitch2 } else { add-VMNetworkAdapter -VMName $vm.VMName -SwitchName $vm.NetworkSwitch2 } #remove the network adapter without a SwitchName from the VM get-VMNetworkAdapter -VMName $vm.VMName | where {$_.SwitchName -ne $switchprivate -and $_.SwitchName -ne $switchInternet } |Remove-VMNetworkAdapter # Set boot order $bootOrder = @() if ($vm.BootOrder -eq \"DVD\") { $bootOrder += Get-VMDvdDrive -VMName $vm.VMName $bootOrder += Get-VMHardDiskDrive -VMName $vm.VMName | Where-Object { $_.ControllerLocation -eq 0 } } elseif ($vm.BootOrder -eq \"Network\") { $bootOrder += Get-VMNetworkAdapter -VMName $vm.VMName| where {$_.SwitchName -eq $switchprivate} $bootOrder += Get-VMHardDiskDrive -VMName $vm.VMName | Where-Object { $_.ControllerLocation -eq 0 } } # Set the boot order for the VM Set-VMFirmware -VMName $vm.VMName -BootOrder $bootOrder -EnableSecureBoot Off } Mistakes made Memory needs to be at 1GB. Any lower the Ubuntu will fail to install. Wasted a few days to catch this. If you are using the download ISO to memory then you need to have a minimum of 4GB to load the ISO to memory.","title":"Hyper-V Virtual Machine Powershell script"},{"location":"Document/Introduction/001-Hyper-V-VM-creation/#hyper-v-virtual-machine-powershell-script","text":"As part of a Lab setup, I expect to create and destroy the VM's regularly. To reduce the pain of recreating manually, I use a Powershell script to create the Hyper-V VM's with certain specifications. To use this script, you must have already have a working Hyper-V. You can refer to this link Enable Hyper-V on Windows 11 To use this script:- - run Powershell ISE as admin. - Save a file to a working folder with the content below. - The script uses the f:\\ drive you may want to change it to match the drive you have. - You also need to create a file 001-Kubernetes-Create-HyperV-VM-v1.1.csv with the content stated in the script. This will be the source for the VM's to be created. - Once the file is saved click on the Green Play button, this will execute the script. // method to access Video-- QR code? Here is a video that might help # create working folder # this script will default to F:\\kubernetes-project-lab # Change the Drive letter to on that exists on your computer, Set-ExecutionPolicy -ExecutionPolicy RemoteSigned <# example content of \"vms.csv\" You can change the VM name VMName,NetworkSwitch1,NetworkSwitch2,DiskSizeGB1,DiskSizeGB2,CPUCount,MemoryGB,ISOPath,BootOrder alpine1,Internet,\"Private 192.168.100.0/24\",50,,1,1,alpine-standard-3.18.4-x86_64.iso,DVD loadbalancer,,\"Private 192.168.100.0/24\",50,,1,1,alpine-standard-3.18.4-x86_64.iso,Network master1,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network master1,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network master2,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network master3,,\"Private 192.168.100.0/24\",50,,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network worker1,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network worker2,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network worker3,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network xsinglenode,,\"Private 192.168.100.0/24\",50,30,1,1,ubuntu-20.04.6-live-server-amd64.iso,Network ## NetworkSwitch1 : this is the internet connection NetworkSwitch2 : this is the private network \"Private 192.168.100.0/24\" ISOPath : if there is a DVD loaded the iso name is listed here. BootOrder : DVD > First Boot DVD, Second Boot HDD Network > First Boot Network \"Private 192.168.100.0/24\" , Second Boot HDD #> # Get the directory containing the script $scriptDirectory = Split-Path -Parent $MyInvocation.MyCommand.Path # Set the path to the CSV file $csvPath = \"$scriptDirectory\\vms.csv\" # Read the CSV file $vms = Import-Csv -Path $csvPath # create working folder #this is where the Hyper-V files will be created. # this script will default to F:\\kubernetes-project-lab $workingfolder = \"F:\\kubernetes-project-lab\" if (!(Test-Path -Path \"$workingfolder\" -PathType Container)) { New-Item -Path \"$workingfolder\" -ItemType Directory } ### Download the ISO images to the folder listed here. $isofolder = \"$workingfolder\\iso\\\" if (!(Test-Path -Path \"$isofolder\" -PathType Container)) { New-Item -Path \"$isofolder\" -ItemType Directory } ## Download alpine iso $outputPath = $DVDalpine $url = \"https://dl-cdn.alpinelinux.org/alpine/v3.18/releases/x86_64/alpine-standard-3.18.4-x86_64.iso\" $DVDalpine=Join-Path $isofolder (Split-Path $url -Leaf) # extracts filename from downloadurl # download if file does not already exist if (!(Test-Path -Path \"$DVDalpine\")) { Invoke-WebRequest -Uri $url -OutFile $outputPath } ## Download Ubunto iso $outputPath = $DVDUBUNTU $url = \"https://releases.ubuntu.com/focal/ubuntu-20.04.6-live-server-amd64.iso\" $DVDUBUNTU = Join-Path $isofolder (Split-Path $url -Leaf) # extracts filename from download # download if file does not already exist if (!(Test-Path -Path \"$DVDUBUNTU\")) { Invoke-WebRequest -Uri $url -OutFile $outputPath } ## change the name to the switch that has access to the internet. ## Hyper-V > Virtual Switch Manager > Identify the Switch names $switchInternet=\"internet\" ## this subnet is used for this example this is a label so any other subnet can be used for the VM's. $switchprivate=\"Private 192.168.100.0/24\" ## ### Creates new private network. $existingSwitch = Get-VMSwitch -Name $switchprivate -SwitchType Internal -ErrorAction SilentlyContinue if ($existingSwitch.name -eq $null) { New-VMSwitch -Name $switchprivate -SwitchType Internal -Notes \"created for k8s-lab project \" } else { Write-Host \"The switch '$switchprivate' already exists.\" } # VM creation begins here. foreach ($vm in $vms) { $vmfolder = \"$workingfolder\\VirtualMachines\\$($vm.VMName)\" # Intialize variable typess to enable provisioning of Hyper-V VM. [int64]$RAM=$null [int64]$RAMmax=$null [System.UInt64]$Disksize1=$null [System.UInt64]$Disksize2=$null # VM CPU and Memory config New-VM -Name $vm.VMName -Generation 2 -Path $vmfolder $RAM = (1GB * $vm.MemoryGB) $RAMmax=(2GB * $vm.MemoryGB) set-VM -Name $vm.VMName -MemoryStartupBytes $RAM Set-VM -VMName $vm.VMName -ProcessorCount $vm.CPUCount # -DynamicMemory -MemoryMaximumBytes $RAMmax -MemoryStartupBytes $RAM # Hard disk Primary OS [System.UInt64]$Disksize1=([long]$vm.DiskSizeGB1 * 1GB) [System.UInt64]$Disksize2=([long]$vm.DiskSizeGB2 * 1GB) $diskPath1 = Join-Path $vmfolder \"$($vm.VMName)-hdd1.vhdx\" New-VHD -Path $diskPath1 -SizeBytes $Disksize1 -Dynamic Add-VMHardDiskDrive -VMName $vm.VMName -Path $diskPath1 -ControllerType SCSI -ControllerLocation 0 # Additional Hard disk if ($vm.DiskSizeGB2 -ne \"\") { $diskPath2 = Join-Path $vmfolder \"$($vm.VMName)-hdd2.vhdx\" New-VHD -Path $diskPath2 -SizeBytes $Disksize2 -Dynamic Add-VMHardDiskDrive -VMName $vm.VMName -Path $diskPath2 -ControllerType SCSI -ControllerLocation 1 } else { \"Disk2 not required\" } # Load ISO drive for installation $isoPath = Join-Path \"$workingfolder\\iso\" $($vm.ISOPath) add-VMDvdDrive -VMName $vm.VMName -Path $isoPath -ControllerLocation 3 #Network adapters if($vm.NetworkSwitch1 -ne \"\") { add-VMNetworkAdapter -VMName $vm.VMName -SwitchName $vm.NetworkSwitch1 add-VMNetworkAdapter -VMName $vm.VMName -SwitchName $vm.NetworkSwitch2 } else { add-VMNetworkAdapter -VMName $vm.VMName -SwitchName $vm.NetworkSwitch2 } #remove the network adapter without a SwitchName from the VM get-VMNetworkAdapter -VMName $vm.VMName | where {$_.SwitchName -ne $switchprivate -and $_.SwitchName -ne $switchInternet } |Remove-VMNetworkAdapter # Set boot order $bootOrder = @() if ($vm.BootOrder -eq \"DVD\") { $bootOrder += Get-VMDvdDrive -VMName $vm.VMName $bootOrder += Get-VMHardDiskDrive -VMName $vm.VMName | Where-Object { $_.ControllerLocation -eq 0 } } elseif ($vm.BootOrder -eq \"Network\") { $bootOrder += Get-VMNetworkAdapter -VMName $vm.VMName| where {$_.SwitchName -eq $switchprivate} $bootOrder += Get-VMHardDiskDrive -VMName $vm.VMName | Where-Object { $_.ControllerLocation -eq 0 } } # Set the boot order for the VM Set-VMFirmware -VMName $vm.VMName -BootOrder $bootOrder -EnableSecureBoot Off } Mistakes made Memory needs to be at 1GB. Any lower the Ubuntu will fail to install. Wasted a few days to catch this. If you are using the download ISO to memory then you need to have a minimum of 4GB to load the ISO to memory.","title":"Hyper-V Virtual Machine Powershell script"},{"location":"Document/Pre%20Requisites/002-vi-basics/","text":"VI basics","title":"002 vi basics"},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/","text":"alpine1 setup and configuration. Ubuntu Autoinstall on single VM One other aspect I was looking at is to automate all the servers to access the configuration files that is reference with the hostname,IP,gateway and Disk config. This way every time I have to rebuild the lab, it will be quicker. I understand from the Ubuntu Automated Server installation that there is a change from version 20.04 a new method is implemented. As such most of the information gathered are from the Ubuntu forums. These are some references I used to prepare the autoinstall configuration autoinstall-quickstart fetch-autoinstall-based-on-mac Lets get to the details The autoinstall requires user-data , vendor-data and meta-data . The meta-data and , vendor-data are blank files. user-data however must be populated with some valid content. In the file /srv/tftp/efi64/pxelinux.cfg/default , the append row below looks for the user-data and meta-data we need to ensure these file exists is referenced here. `autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstalldata/` Example of user-data . This was obtained from a manual installation of ubuntu-20.04.6-live-server-amd64.iso . The file autoinstall-user-data is found in the folder /var/log/installer/autoinstall-user-data . It is best to generate one to store the relevant configurations and then customize based on individual server requirements. Lets create this file. # this is a blank file touch /srv/autoinstall/meta-data touch /srv/autoinstall/vendor-data touch /srv/autoinstall/user-data vi /srv/autoinstall/user-data #cloud-config autoinstall: apt: disable_components: [] geoip: true preserve_sources_list: false primary: - arches: - amd64 - i386 uri: http://my.archive.ubuntu.com/ubuntu - arches: - default uri: http://ports.ubuntu.com/ubuntu-ports drivers: install: false identity: hostname: master1 password: $5$1hs/5SKiGm.zNbWk$Ap5W6Tc.YCaALtSp1INrLmYD/GIpRemhpRwtZIZCSO9 realname: ss username: ubuntu kernel: package: linux-generic keyboard: layout: us toggle: null variant: '' locale: en_US.UTF-8 network: ethernets: eth0: addresses: - 192.168.100.202/24 gateway4: 192.168.100.1 nameservers: addresses: - 192.168.100.1 search: [] version: 2 ssh: allow-pw: true authorized-keys: [] install-server: true storage: config: - ptable: gpt path: /dev/sda wipe: superblock preserve: false name: '' grub_device: false type: disk id: disk-sda - device: disk-sda size: 1127219200 wipe: superblock flag: boot number: 1 preserve: false grub_device: true type: partition id: partition-0 - fstype: fat32 volume: partition-0 preserve: false type: format id: format-0 - device: disk-sda size: 2147483648 wipe: superblock flag: '' number: 2 preserve: false grub_device: false type: partition id: partition-1 - fstype: ext4 volume: partition-1 preserve: false type: format id: format-1 - device: disk-sda size: 50410291200 wipe: superblock flag: '' number: 3 preserve: false grub_device: false type: partition id: partition-2 - name: ubuntu-vg devices: - partition-2 preserve: false type: lvm_volgroup id: lvm_volgroup-0 - name: ubuntu-lv volgroup: lvm_volgroup-0 size: 25203572736B wipe: superblock preserve: false type: lvm_partition id: lvm_partition-0 - fstype: ext4 volume: lvm_partition-0 preserve: false type: format id: format-2 - path: / device: format-2 type: mount id: mount-2 - path: /boot device: format-1 type: mount id: mount-1 - path: /boot/efi device: format-0 type: mount id: mount-0 updates: security version: 1 Generate the crypted password using the command below. The result will change with every run as there is salting present in the code.You don't have to do this if you are extracting the user-data from an existing installation. mkpasswd --method=sha-512 123 # 123 is the password in this example Validate Validate user-data using the command below. cloud-init schema --config-file user-data We now have all the files in place for a machine to start up and autoinstall ubuntu. With the setup in place you can now start the Virtual Machine master1 , the network boot will present the Menu, select the option ubuntu-iso-local the VM will boot up with and the installation will complete without manual input. Video overview on the Ubuntu Autoinstall process . This a video covering the initial boot, Ubuntu installation and the booting to the newly installed Ubuntu. Autoinstall-Ubuntu-master1 update to include new link Troubleshooting steps. As I performed the configuration, I faced some issues , and the following had configuration errors mostly. i.e. wrong IP, typos etc. check dhcp Ensure the IP Addresses are assigned correctly. Check nginx You can use the access log to check if a URL has been accessed. This way you can guess where the errors could be. Ensure Virtual Machine specifications meet the minimum requirements. I had set the Memory to 512MB and enabled Dynamic memory of 512MB to 2048GB but this caused the autoinstall to crash and not complete. if you choose ubuntu-iso-remote ensure VM has minimum 4GB of memory to load the Ubuntu OS setup. This is for the ISO to be extracted to memory. URL path incorrect Many times I found myself making simple mistakes in the path. Double check if you did the same too. meta-data and vendor-data not created or path configured does not have meta-data and vendor-data","title":"alpine1 setup and configuration."},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#alpine1-setup-and-configuration","text":"","title":"alpine1 setup and configuration."},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#ubuntu-autoinstall-on-single-vm","text":"One other aspect I was looking at is to automate all the servers to access the configuration files that is reference with the hostname,IP,gateway and Disk config. This way every time I have to rebuild the lab, it will be quicker. I understand from the Ubuntu Automated Server installation that there is a change from version 20.04 a new method is implemented. As such most of the information gathered are from the Ubuntu forums.","title":"Ubuntu Autoinstall on single VM"},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#these-are-some-references-i-used-to-prepare-the-autoinstall-configuration","text":"autoinstall-quickstart fetch-autoinstall-based-on-mac","title":"These are some references I used to prepare the autoinstall configuration"},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#lets-get-to-the-details","text":"The autoinstall requires user-data , vendor-data and meta-data . The meta-data and , vendor-data are blank files. user-data however must be populated with some valid content. In the file /srv/tftp/efi64/pxelinux.cfg/default , the append row below looks for the user-data and meta-data we need to ensure these file exists is referenced here. `autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstalldata/` Example of user-data . This was obtained from a manual installation of ubuntu-20.04.6-live-server-amd64.iso . The file autoinstall-user-data is found in the folder /var/log/installer/autoinstall-user-data . It is best to generate one to store the relevant configurations and then customize based on individual server requirements. Lets create this file. # this is a blank file touch /srv/autoinstall/meta-data touch /srv/autoinstall/vendor-data touch /srv/autoinstall/user-data vi /srv/autoinstall/user-data #cloud-config autoinstall: apt: disable_components: [] geoip: true preserve_sources_list: false primary: - arches: - amd64 - i386 uri: http://my.archive.ubuntu.com/ubuntu - arches: - default uri: http://ports.ubuntu.com/ubuntu-ports drivers: install: false identity: hostname: master1 password: $5$1hs/5SKiGm.zNbWk$Ap5W6Tc.YCaALtSp1INrLmYD/GIpRemhpRwtZIZCSO9 realname: ss username: ubuntu kernel: package: linux-generic keyboard: layout: us toggle: null variant: '' locale: en_US.UTF-8 network: ethernets: eth0: addresses: - 192.168.100.202/24 gateway4: 192.168.100.1 nameservers: addresses: - 192.168.100.1 search: [] version: 2 ssh: allow-pw: true authorized-keys: [] install-server: true storage: config: - ptable: gpt path: /dev/sda wipe: superblock preserve: false name: '' grub_device: false type: disk id: disk-sda - device: disk-sda size: 1127219200 wipe: superblock flag: boot number: 1 preserve: false grub_device: true type: partition id: partition-0 - fstype: fat32 volume: partition-0 preserve: false type: format id: format-0 - device: disk-sda size: 2147483648 wipe: superblock flag: '' number: 2 preserve: false grub_device: false type: partition id: partition-1 - fstype: ext4 volume: partition-1 preserve: false type: format id: format-1 - device: disk-sda size: 50410291200 wipe: superblock flag: '' number: 3 preserve: false grub_device: false type: partition id: partition-2 - name: ubuntu-vg devices: - partition-2 preserve: false type: lvm_volgroup id: lvm_volgroup-0 - name: ubuntu-lv volgroup: lvm_volgroup-0 size: 25203572736B wipe: superblock preserve: false type: lvm_partition id: lvm_partition-0 - fstype: ext4 volume: lvm_partition-0 preserve: false type: format id: format-2 - path: / device: format-2 type: mount id: mount-2 - path: /boot device: format-1 type: mount id: mount-1 - path: /boot/efi device: format-0 type: mount id: mount-0 updates: security version: 1 Generate the crypted password using the command below. The result will change with every run as there is salting present in the code.You don't have to do this if you are extracting the user-data from an existing installation. mkpasswd --method=sha-512 123 # 123 is the password in this example","title":"Lets get to the details"},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#validate","text":"Validate user-data using the command below. cloud-init schema --config-file user-data We now have all the files in place for a machine to start up and autoinstall ubuntu. With the setup in place you can now start the Virtual Machine master1 , the network boot will present the Menu, select the option ubuntu-iso-local the VM will boot up with and the installation will complete without manual input.","title":"Validate"},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#video-overview-on-the-ubuntu-autoinstall-process","text":"This a video covering the initial boot, Ubuntu installation and the booting to the newly installed Ubuntu. Autoinstall-Ubuntu-master1","title":"Video overview on the Ubuntu Autoinstall process ."},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#update-to-include-new-link","text":"","title":"update to include new link"},{"location":"Document/Virtual%20Machine%20Deployment/113-New-single-VM-setup-Ubuntu-autoinstall/#troubleshooting-steps","text":"As I performed the configuration, I faced some issues , and the following had configuration errors mostly. i.e. wrong IP, typos etc. check dhcp Ensure the IP Addresses are assigned correctly. Check nginx You can use the access log to check if a URL has been accessed. This way you can guess where the errors could be. Ensure Virtual Machine specifications meet the minimum requirements. I had set the Memory to 512MB and enabled Dynamic memory of 512MB to 2048GB but this caused the autoinstall to crash and not complete. if you choose ubuntu-iso-remote ensure VM has minimum 4GB of memory to load the Ubuntu OS setup. This is for the ISO to be extracted to memory. URL path incorrect Many times I found myself making simple mistakes in the path. Double check if you did the same too. meta-data and vendor-data not created or path configured does not have meta-data and vendor-data","title":"Troubleshooting steps."},{"location":"Document/Virtual%20Machine%20Deployment/114-generate-user-data-multipleVM/","text":"Generate user-data-mac-address file. For a Kubernetes cluster we will need multiple Virtual Machines. This will require multiple user-data-mac-address files to be created. Here I use PowerShellt to generate the files. To setup each Hyper-V VM with the Ubuntu Operating system we need to generate unique user-data files. The following script generates the script based on a working user-data file. This working file was extracted by installing Ubuntu from scratch with the relevant configurations. This file can be obtained from /var/log/installer/autoinstall-user-data . This file is renamed as user-data-template.yaml in this script. The script then creates new files based on the mac-address with the hostname and IP address updated. # Get the directory containing the script $scriptDirectory = Split-Path -Parent $MyInvocation.MyCommand.Path # Set the path to the script file Set-Location $scriptDirectory $output = \"$scriptDirectory\\autoinstall\" if ((Test-Path -Path $output) -ne \"True\") { New-Item -Path $output -ItemType Directory } # Define a hashtable for mapping hostnames to IP addresses $ipAddressMap = @{ \"alpine1\" = \"192.168.100.201\" \"loadbalancer\" = \"192.168.100.202\" \"master1\" = \"192.168.100.203\" \"master2\" = \"192.168.100.204\" \"master3\" = \"192.168.100.205\" \"worker1\" = \"192.168.100.206\" \"worker2\" = \"192.168.100.207\" \"worker3\" = \"192.168.100.208\" \"xsinglenode\" = \"192.168.100.209\" \"xsingleubuntu\" = \"192.168.100.210\" } # Get all virtual machines $vms = Get-VM # Iterate through each virtual machine foreach ($vm in $vms) { # Get MAC address of the first network adapter $macAddress = $vm | Get-VMNetworkAdapter | Select-Object -First 1 | Select-Object -ExpandProperty MacAddress # Remove \"k8s-\" prefix from the VM name $vmName = $vm.Name -replace '^k8s-', '' # Format MAC address $formattedMacAddress = ($macAddress -replace '(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})', '$1-$2-$3-$4-$5-$6').ToLower() # Get IP address from the mapping $ipAddress = $ipAddressMap[$vmName] if (-not $ipAddress) { Write-Host \"Error: IP address not found for '$vmName'.\" continue } # Format DHCP configuration $dhcpConfig = @\" host $vmName { hardware ethernet $formattedMacAddress; fixed-address $ipAddress; option host-name \"$vmName\"; } \"@ Write-Host \"----------------------\" # Output results # Write-Host \"VM Name: $vmName\" # Write-Host \"MAC Address: $formattedMacAddress\" Write-Host \"IP Address: $ipAddress\" # Write-Host \"Server Name: $($env:COMPUTERNAME)\" # Write to the CSV file $mac = \" $vmName,$formattedMacAddress,$ipAddress\" Write-Host $mac $mac | Out-File $output\\mac-address-list.csv -Append # Create user-data files # Create user-data files $userDataFile = \"$output\\user-data-$formattedMacAddress\" if (-not (Test-Path $userDataFile)) { # File doesn't exist, create it by copying the template Copy-Item -Path \"user-data-template.yaml\" -Destination $userDataFile Write-Host \"File created: $userDataFile\" } #this following file is to be able to identify the mac address with hostname directly from the filename if (-not (Test-Path $userdatafile-$vmName)) { # File doesn't exist, create it New-Item -ItemType File -Path $userdatafile-$vmName Write-Host \"File created: $userdatafile-$vmName\" } # Get content of the template file $userDataContent = Get-Content -Path $userDataFile -Raw # Replace the placeholders with predetermined values $userDataContent = $userDataContent -replace 'hostname: master1', \"hostname: $vmName\" $userDataContent = $userDataContent -replace '192.168.100.202/24', \"$ipAddress/24\" # Set the modified content back to the user-data file Set-Content -Path $userDataFile -Value $userDataContent Write-Host \"----------------------\" } This script references 2 different files user-data-early and another for user-data-template . These 2 files have some differences. user-data On row 2 contains the entry autoinstall: On row 28 and 29 contains the early command . This is when the file user-data-mac-address is downloaded to autoinstall.yaml user-data-early early-commands: - curl -G -o /autoinstall.yaml http://192.168.100.1/autoinstall/user-data-\"$(ip a | grep ether | awk '{print $2}' | tr ':' '-')\" user-data-template Does not have the autoinstall: entry. Having this entry will cause the installation to fail. Does not have the early command to download the user-data-template as this was already done. The generated files are in the subfolder .\\autoinstall\\ From the configuration in step 112 , the Boot sequence is looking up the location. http://192.168.100.1/autoinstall/ This is from the following code APPEND netboot=nfs boot=casper root=/dev/nfs nfsroot=192.168.100.1:/srv/isoubuntu autoinstall Copy the files created to the folder /srv/autoinstall/ on the alpine1 server. The duplicate file with the node name is workaround to show the hostname of the specific file. As I did not find away to identify the hostname using the Ubuntu autoinstall method. If you recall from 104-setup-nginx, the folder /srv/ was exposed to be visible from http://192.168.100.1/ . All folders created in /srv/ will be listed via the browser. Copy the files using WSFTP or some other method . Validate by browsing http://192.168.100.1/ To update Video of Script generation and the Ubuntu setup. , vendor-data","title":"114 generate user data multipleVM"},{"location":"Document/Virtual%20Machine%20Deployment/114-generate-user-data-multipleVM/#generate-user-data-mac-address-file","text":"For a Kubernetes cluster we will need multiple Virtual Machines. This will require multiple user-data-mac-address files to be created. Here I use PowerShellt to generate the files. To setup each Hyper-V VM with the Ubuntu Operating system we need to generate unique user-data files. The following script generates the script based on a working user-data file. This working file was extracted by installing Ubuntu from scratch with the relevant configurations. This file can be obtained from /var/log/installer/autoinstall-user-data . This file is renamed as user-data-template.yaml in this script. The script then creates new files based on the mac-address with the hostname and IP address updated. # Get the directory containing the script $scriptDirectory = Split-Path -Parent $MyInvocation.MyCommand.Path # Set the path to the script file Set-Location $scriptDirectory $output = \"$scriptDirectory\\autoinstall\" if ((Test-Path -Path $output) -ne \"True\") { New-Item -Path $output -ItemType Directory } # Define a hashtable for mapping hostnames to IP addresses $ipAddressMap = @{ \"alpine1\" = \"192.168.100.201\" \"loadbalancer\" = \"192.168.100.202\" \"master1\" = \"192.168.100.203\" \"master2\" = \"192.168.100.204\" \"master3\" = \"192.168.100.205\" \"worker1\" = \"192.168.100.206\" \"worker2\" = \"192.168.100.207\" \"worker3\" = \"192.168.100.208\" \"xsinglenode\" = \"192.168.100.209\" \"xsingleubuntu\" = \"192.168.100.210\" } # Get all virtual machines $vms = Get-VM # Iterate through each virtual machine foreach ($vm in $vms) { # Get MAC address of the first network adapter $macAddress = $vm | Get-VMNetworkAdapter | Select-Object -First 1 | Select-Object -ExpandProperty MacAddress # Remove \"k8s-\" prefix from the VM name $vmName = $vm.Name -replace '^k8s-', '' # Format MAC address $formattedMacAddress = ($macAddress -replace '(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})', '$1-$2-$3-$4-$5-$6').ToLower() # Get IP address from the mapping $ipAddress = $ipAddressMap[$vmName] if (-not $ipAddress) { Write-Host \"Error: IP address not found for '$vmName'.\" continue } # Format DHCP configuration $dhcpConfig = @\" host $vmName { hardware ethernet $formattedMacAddress; fixed-address $ipAddress; option host-name \"$vmName\"; } \"@ Write-Host \"----------------------\" # Output results # Write-Host \"VM Name: $vmName\" # Write-Host \"MAC Address: $formattedMacAddress\" Write-Host \"IP Address: $ipAddress\" # Write-Host \"Server Name: $($env:COMPUTERNAME)\" # Write to the CSV file $mac = \" $vmName,$formattedMacAddress,$ipAddress\" Write-Host $mac $mac | Out-File $output\\mac-address-list.csv -Append # Create user-data files # Create user-data files $userDataFile = \"$output\\user-data-$formattedMacAddress\" if (-not (Test-Path $userDataFile)) { # File doesn't exist, create it by copying the template Copy-Item -Path \"user-data-template.yaml\" -Destination $userDataFile Write-Host \"File created: $userDataFile\" } #this following file is to be able to identify the mac address with hostname directly from the filename if (-not (Test-Path $userdatafile-$vmName)) { # File doesn't exist, create it New-Item -ItemType File -Path $userdatafile-$vmName Write-Host \"File created: $userdatafile-$vmName\" } # Get content of the template file $userDataContent = Get-Content -Path $userDataFile -Raw # Replace the placeholders with predetermined values $userDataContent = $userDataContent -replace 'hostname: master1', \"hostname: $vmName\" $userDataContent = $userDataContent -replace '192.168.100.202/24', \"$ipAddress/24\" # Set the modified content back to the user-data file Set-Content -Path $userDataFile -Value $userDataContent Write-Host \"----------------------\" } This script references 2 different files user-data-early and another for user-data-template . These 2 files have some differences. user-data On row 2 contains the entry autoinstall: On row 28 and 29 contains the early command . This is when the file user-data-mac-address is downloaded to autoinstall.yaml user-data-early early-commands: - curl -G -o /autoinstall.yaml http://192.168.100.1/autoinstall/user-data-\"$(ip a | grep ether | awk '{print $2}' | tr ':' '-')\" user-data-template Does not have the autoinstall: entry. Having this entry will cause the installation to fail. Does not have the early command to download the user-data-template as this was already done. The generated files are in the subfolder .\\autoinstall\\ From the configuration in step 112 , the Boot sequence is looking up the location. http://192.168.100.1/autoinstall/ This is from the following code APPEND netboot=nfs boot=casper root=/dev/nfs nfsroot=192.168.100.1:/srv/isoubuntu autoinstall Copy the files created to the folder /srv/autoinstall/ on the alpine1 server. The duplicate file with the node name is workaround to show the hostname of the specific file. As I did not find away to identify the hostname using the Ubuntu autoinstall method. If you recall from 104-setup-nginx, the folder /srv/ was exposed to be visible from http://192.168.100.1/ . All folders created in /srv/ will be listed via the browser. Copy the files using WSFTP or some other method . Validate by browsing http://192.168.100.1/ To update Video of Script generation and the Ubuntu setup. , vendor-data","title":"Generate user-data-mac-address file."},{"location":"Document/Virtual%20Machine%20Deployment/114-generate-user-data-reference/","text":"Gotchas In preparing the autoinstall I had a few mistakes I made and identifying them did take alot of time. Ensure Virtual Machine specifications meet the minimum requirements. I had set the Memory to 512MB and enabled Dynamic memory of 512MB to 2048GB but this caused the autoinstall to crash and not complete. The second issue I faced was to use the incorrect entries for user-data-early and user-data-template.yaml . Please refer to the content I used below. user-data-early content. #cloud-config autoinstall: apt: disable_components: [] geoip: true preserve_sources_list: false primary: - arches: - amd64 - i386 uri: http://my.archive.ubuntu.com/ubuntu - arches: - default uri: http://ports.ubuntu.com/ubuntu-ports drivers: install: false identity: hostname: master1 password: $5$1hs/5SKiGm.zNbWk$Ap5W6Tc.YCaALtSp1INrLmYD/GIpRemhpRwtZIZCSO9 realname: ss username: ubuntu kernel: package: linux-generic keyboard: layout: us toggle: null variant: '' early-commands: - curl -G -o /autoinstall.yaml http://192.168.100.1/autoinstall/user-data-\"$(ip a | grep ether | awk '{print $2}' | tr ':' '-')\" locale: en_US.UTF-8 network: ethernets: eth0: addresses: - 192.168.100.201/24 gateway4: 192.168.100.1 nameservers: addresses: - 192.168.100.1 - 8.8.8.8 search: [k8s.lab] version: 2 ssh: allow-pw: true authorized-keys: [] install-server: true storage: config: - ptable: gpt path: /dev/sda wipe: superblock preserve: false name: '' grub_device: false type: disk id: disk-sda - device: disk-sda size: 1127219200 wipe: superblock flag: boot number: 1 preserve: false grub_device: true type: partition id: partition-0 - fstype: fat32 volume: partition-0 preserve: false type: format id: format-0 - device: disk-sda size: 2147483648 wipe: superblock flag: '' number: 2 preserve: false grub_device: false type: partition id: partition-1 - fstype: ext4 volume: partition-1 preserve: false type: format id: format-1 - device: disk-sda size: 50410291200 wipe: superblock flag: '' number: 3 preserve: false grub_device: false type: partition id: partition-2 - name: ubuntu-vg devices: - partition-2 preserve: false type: lvm_volgroup id: lvm_volgroup-0 - name: ubuntu-lv volgroup: lvm_volgroup-0 size: 25203572736B wipe: superblock preserve: false type: lvm_partition id: lvm_partition-0 - fstype: ext4 volume: lvm_partition-0 preserve: false type: format id: format-2 - path: / device: format-2 type: mount id: mount-2 - path: /boot device: format-1 type: mount id: mount-1 - path: /boot/efi device: format-0 type: mount id: mount-0 version: 1 user-data-template.yaml #cloud-config apt: disable_components: [] geoip: true preserve_sources_list: false primary: - arches: - amd64 - i386 uri: http://my.archive.ubuntu.com/ubuntu - arches: - default uri: http://ports.ubuntu.com/ubuntu-ports drivers: install: false identity: hostname: master1 password: $5$1hs/5SKiGm.zNbWk$Ap5W6Tc.YCaALtSp1INrLmYD/GIpRemhpRwtZIZCSO9 realname: ss username: ubuntu kernel: package: linux-generic keyboard: layout: us toggle: null variant: '' locale: en_US.UTF-8 network: ethernets: eth0: addresses: - 192.168.100.202/24 gateway4: 192.168.100.1 nameservers: addresses: - 192.168.100.1 - 8.8.8.8 search: [k8s.lab] version: 2 ssh: allow-pw: true authorized-keys: [] install-server: true storage: config: - ptable: gpt path: /dev/sda wipe: superblock preserve: false name: '' grub_device: false type: disk id: disk-sda - device: disk-sda size: 1127219200 wipe: superblock flag: boot number: 1 preserve: false grub_device: true type: partition id: partition-0 - fstype: fat32 volume: partition-0 preserve: false type: format id: format-0 - device: disk-sda size: 2147483648 wipe: superblock flag: '' number: 2 preserve: false grub_device: false type: partition id: partition-1 - fstype: ext4 volume: partition-1 preserve: false type: format id: format-1 - device: disk-sda size: 50410291200 wipe: superblock flag: '' number: 3 preserve: false grub_device: false type: partition id: partition-2 - name: ubuntu-vg devices: - partition-2 preserve: false type: lvm_volgroup id: lvm_volgroup-0 - name: ubuntu-lv volgroup: lvm_volgroup-0 size: 25203572736B wipe: superblock preserve: false type: lvm_partition id: lvm_partition-0 - fstype: ext4 volume: lvm_partition-0 preserve: false type: format id: format-2 - path: / device: format-2 type: mount id: mount-2 - path: /boot device: format-1 type: mount id: mount-1 - path: /boot/efi device: format-0 type: mount id: mount-0 updates: security version: 1 Here is a screenshot of the error when the autoinstall entry is not removed from user-data-template.yaml The setup will continue but will stop, only when you press enter the script will exit.","title":"114 generate user data reference"},{"location":"Document/Virtual%20Machine%20Deployment/114-generate-user-data-reference/#gotchas","text":"In preparing the autoinstall I had a few mistakes I made and identifying them did take alot of time. Ensure Virtual Machine specifications meet the minimum requirements. I had set the Memory to 512MB and enabled Dynamic memory of 512MB to 2048GB but this caused the autoinstall to crash and not complete. The second issue I faced was to use the incorrect entries for user-data-early and user-data-template.yaml . Please refer to the content I used below. user-data-early content. #cloud-config autoinstall: apt: disable_components: [] geoip: true preserve_sources_list: false primary: - arches: - amd64 - i386 uri: http://my.archive.ubuntu.com/ubuntu - arches: - default uri: http://ports.ubuntu.com/ubuntu-ports drivers: install: false identity: hostname: master1 password: $5$1hs/5SKiGm.zNbWk$Ap5W6Tc.YCaALtSp1INrLmYD/GIpRemhpRwtZIZCSO9 realname: ss username: ubuntu kernel: package: linux-generic keyboard: layout: us toggle: null variant: '' early-commands: - curl -G -o /autoinstall.yaml http://192.168.100.1/autoinstall/user-data-\"$(ip a | grep ether | awk '{print $2}' | tr ':' '-')\" locale: en_US.UTF-8 network: ethernets: eth0: addresses: - 192.168.100.201/24 gateway4: 192.168.100.1 nameservers: addresses: - 192.168.100.1 - 8.8.8.8 search: [k8s.lab] version: 2 ssh: allow-pw: true authorized-keys: [] install-server: true storage: config: - ptable: gpt path: /dev/sda wipe: superblock preserve: false name: '' grub_device: false type: disk id: disk-sda - device: disk-sda size: 1127219200 wipe: superblock flag: boot number: 1 preserve: false grub_device: true type: partition id: partition-0 - fstype: fat32 volume: partition-0 preserve: false type: format id: format-0 - device: disk-sda size: 2147483648 wipe: superblock flag: '' number: 2 preserve: false grub_device: false type: partition id: partition-1 - fstype: ext4 volume: partition-1 preserve: false type: format id: format-1 - device: disk-sda size: 50410291200 wipe: superblock flag: '' number: 3 preserve: false grub_device: false type: partition id: partition-2 - name: ubuntu-vg devices: - partition-2 preserve: false type: lvm_volgroup id: lvm_volgroup-0 - name: ubuntu-lv volgroup: lvm_volgroup-0 size: 25203572736B wipe: superblock preserve: false type: lvm_partition id: lvm_partition-0 - fstype: ext4 volume: lvm_partition-0 preserve: false type: format id: format-2 - path: / device: format-2 type: mount id: mount-2 - path: /boot device: format-1 type: mount id: mount-1 - path: /boot/efi device: format-0 type: mount id: mount-0 version: 1 user-data-template.yaml #cloud-config apt: disable_components: [] geoip: true preserve_sources_list: false primary: - arches: - amd64 - i386 uri: http://my.archive.ubuntu.com/ubuntu - arches: - default uri: http://ports.ubuntu.com/ubuntu-ports drivers: install: false identity: hostname: master1 password: $5$1hs/5SKiGm.zNbWk$Ap5W6Tc.YCaALtSp1INrLmYD/GIpRemhpRwtZIZCSO9 realname: ss username: ubuntu kernel: package: linux-generic keyboard: layout: us toggle: null variant: '' locale: en_US.UTF-8 network: ethernets: eth0: addresses: - 192.168.100.202/24 gateway4: 192.168.100.1 nameservers: addresses: - 192.168.100.1 - 8.8.8.8 search: [k8s.lab] version: 2 ssh: allow-pw: true authorized-keys: [] install-server: true storage: config: - ptable: gpt path: /dev/sda wipe: superblock preserve: false name: '' grub_device: false type: disk id: disk-sda - device: disk-sda size: 1127219200 wipe: superblock flag: boot number: 1 preserve: false grub_device: true type: partition id: partition-0 - fstype: fat32 volume: partition-0 preserve: false type: format id: format-0 - device: disk-sda size: 2147483648 wipe: superblock flag: '' number: 2 preserve: false grub_device: false type: partition id: partition-1 - fstype: ext4 volume: partition-1 preserve: false type: format id: format-1 - device: disk-sda size: 50410291200 wipe: superblock flag: '' number: 3 preserve: false grub_device: false type: partition id: partition-2 - name: ubuntu-vg devices: - partition-2 preserve: false type: lvm_volgroup id: lvm_volgroup-0 - name: ubuntu-lv volgroup: lvm_volgroup-0 size: 25203572736B wipe: superblock preserve: false type: lvm_partition id: lvm_partition-0 - fstype: ext4 volume: lvm_partition-0 preserve: false type: format id: format-2 - path: / device: format-2 type: mount id: mount-2 - path: /boot device: format-1 type: mount id: mount-1 - path: /boot/efi device: format-0 type: mount id: mount-0 updates: security version: 1 Here is a screenshot of the error when the autoinstall entry is not removed from user-data-template.yaml The setup will continue but will stop, only when you press enter the script will exit.","title":"Gotchas"},{"location":"Document/alpine1/100-alpine1-setup/","text":"Initial Alpine OS setup - alpine1 Key information Alpine Default login login : root password : blank Hyper-V configuration for reference Alpine install ISO first boot Disable IPv6 on Alpine In my setup IPv6 was not working.When downloading files IPv6 was used and delayed/errored out. If you have issues with IPv6, do disable before proceeding. Edit the /etc/sysctl.conf vi /etc/sysctl.conf # Manualy type in the followingf # press [i] to be in insert /edit mode net.ipv6.conf.all.disable_ipv6 = 1 # to save and exit following key press # [esc] :x! [enter] # reload the configuration sysctl -p Install Alpine After logging on at the prompt type setup-alpine You will be asked a series of questions . I have listed my selection. Keyboard Layout : [us] Keyboard variant : [us] Hostname : [alpine1] Network : eth0: [dhcp] # Internet connection eth1: [192.168.100.1/24] gateway: [none] password : [123] DNS Servers : Timezone :[Singpore] Proxy :[none] ntp: default [chrony] #if it takes long to complete , make sure ipv6 is disabled Mirror :[f] # Detect and add fastest mirror setup user : [no] Which ssh server? [openssh] allow root ssh login: [yes] Allow ssh login : [yes] Which disks would you like to use : [sda] Disk Mode How would you like to use it ? [sys] Erase the above disks and continue? [y] Installation begins. Once the installation is completed you will see the notice to reboot. Before rebooting, change the boot sequence in Hyper-V for alpine1 to be Hard Drive first. This will ensure the reboot will be to the Hard Disk. On the apline1 Hyper-V console. the prompt will display press [enter] installation complete type reboot [enter] Setup completed These are the credentials for newly installed alpine1 . login: root pass: 123 #in this lab all passwords will be set with 123 This screen will appear , take note of the login prompt 'alpine1' . Indicating the installation is completed. Connect via ssh If you don't already know the Hyper-V console is not able to perform copy and paste operations. Via a terminal connection copy and paste functions make it easier to paste commands , especially the long ones. At this time the Hyper-V host does not have an IP in the Private Subnet 192.168.100.0/24 . We cannot test the SSH at this time. We can test this when DHCP is setup later on. Alpine OS install completed Next step We will proceed to setup alpine1 as a DHCP server Please continue with 101-alpine1-setup-DHCP-server","title":"Initial Alpine OS setup - alpine1"},{"location":"Document/alpine1/100-alpine1-setup/#initial-alpine-os-setup-alpine1","text":"","title":"Initial Alpine OS setup - alpine1"},{"location":"Document/alpine1/100-alpine1-setup/#key-information","text":"Alpine Default login login : root password : blank","title":"Key information"},{"location":"Document/alpine1/100-alpine1-setup/#hyper-v-configuration-for-reference","text":"","title":"Hyper-V configuration for reference"},{"location":"Document/alpine1/100-alpine1-setup/#alpine-install-iso-first-boot","text":"","title":"Alpine install ISO first boot"},{"location":"Document/alpine1/100-alpine1-setup/#disable-ipv6-on-alpine","text":"In my setup IPv6 was not working.When downloading files IPv6 was used and delayed/errored out. If you have issues with IPv6, do disable before proceeding. Edit the /etc/sysctl.conf vi /etc/sysctl.conf # Manualy type in the followingf # press [i] to be in insert /edit mode net.ipv6.conf.all.disable_ipv6 = 1 # to save and exit following key press # [esc] :x! [enter] # reload the configuration sysctl -p","title":"Disable IPv6 on Alpine"},{"location":"Document/alpine1/100-alpine1-setup/#install-alpine","text":"After logging on at the prompt type setup-alpine You will be asked a series of questions . I have listed my selection. Keyboard Layout : [us] Keyboard variant : [us] Hostname : [alpine1] Network : eth0: [dhcp] # Internet connection eth1: [192.168.100.1/24] gateway: [none] password : [123] DNS Servers : Timezone :[Singpore] Proxy :[none] ntp: default [chrony] #if it takes long to complete , make sure ipv6 is disabled Mirror :[f] # Detect and add fastest mirror setup user : [no] Which ssh server? [openssh] allow root ssh login: [yes] Allow ssh login : [yes] Which disks would you like to use : [sda] Disk Mode How would you like to use it ? [sys] Erase the above disks and continue? [y]","title":"Install Alpine"},{"location":"Document/alpine1/100-alpine1-setup/#installation-begins","text":"Once the installation is completed you will see the notice to reboot. Before rebooting, change the boot sequence in Hyper-V for alpine1 to be Hard Drive first. This will ensure the reboot will be to the Hard Disk. On the apline1 Hyper-V console. the prompt will display press [enter] installation complete type reboot [enter]","title":"Installation begins."},{"location":"Document/alpine1/100-alpine1-setup/#setup-completed","text":"These are the credentials for newly installed alpine1 . login: root pass: 123 #in this lab all passwords will be set with 123 This screen will appear , take note of the login prompt 'alpine1' . Indicating the installation is completed.","title":"Setup completed"},{"location":"Document/alpine1/100-alpine1-setup/#connect-via-ssh","text":"If you don't already know the Hyper-V console is not able to perform copy and paste operations. Via a terminal connection copy and paste functions make it easier to paste commands , especially the long ones. At this time the Hyper-V host does not have an IP in the Private Subnet 192.168.100.0/24 . We cannot test the SSH at this time. We can test this when DHCP is setup later on.","title":"Connect via ssh"},{"location":"Document/alpine1/100-alpine1-setup/#alpine-os-install-completed","text":"","title":"Alpine OS install completed"},{"location":"Document/alpine1/100-alpine1-setup/#next-step","text":"We will proceed to setup alpine1 as a DHCP server Please continue with","title":"Next step"},{"location":"Document/alpine1/100-alpine1-setup/#101-alpine1-setup-dhcp-server","text":"","title":"101-alpine1-setup-DHCP-server"},{"location":"Document/alpine1/101-DHCP-server/","text":"Install and Configure DHCP - alpine1 For the initial setup we will have the basic DHCP configuration. #install dhcpd apk add dhcp Update the file /etc/dhcp/dhcpd.conf with the content below. Use VI editor to edit ( or any other you are familiar with) # using console you cannot copy paste, must type in manually # create config file touch /etc/dhcp/dhcpd.conf # edit config file vi /etc/dhcp/dhcpd.conf subnet 192.168.100.0 netmask 255.255.255.0 { range 192.168.100.100 192.168.100.200; option domain-name-servers 192.168.100.1; option routers 192.168.100.1; } [esc] :x[enter] to save and exit routers : The routers IP usually is the WIFI or WAN router IP. In this lab setup we want emulate an office network setup. In the subsequent steps we will review how to setup alpine1 as a Router. domain-name-servers : in this setup we want to resolve some internal hostnames that cannot be resolved by public DNS servers. We want to have alpine1 to function as DNS server and also forward DNS request not resolved locally. The steps to configure alpine1 as DNS server is reviewed later. Restart the DHCP deamon To refresh the updated configuration restart the DHCP services. Any errors in configuration will appear at this point. # set dhcpd to start at boot rc-update add dhcpd default # start the dhcpd service. rc-service dhcpd start # Check the dhcpd service status. rc-service dhcpd status DHCP logs Later you may need to check if the IP addresses are assigned etc. These to files will be key for your troubleshooting. cat /etc/dhcp/dhcpd.conf cat /var/lib/dhcp/dhcpd.leases DHCP Setup is complete for alpine1 server . Steps to ssh. If using DHCP, the gateway is also assigned to my Hyper-V host nic. THis caused some network issues where my connection to the internet kept timing out. When I set the IP address without the Gateway the network issues were no longer present. So better to set the IP address manualy then obtain via DHCP. Paste the following Powershell code int Windows Terminal as Administrator. $ifindex=(Get-NetAdapter | Where-Object { $_.Name -like \"*192.168.100.0*\" }).InterfaceIndex New-NetIPAddress -InterfaceIndex $ifindex -IPAddress 192.168.100.2 -PrefixLength 24 Get-DnsClient -InterfaceIndex $ifindex | Set-DnsClientServerAddress -ServerAddresses (\"192.168.100.1\") Validate Run this command on Windows Terminal to check if an IP has been assigned get-netipaddress -InterfaceIndex (Get-NetAdapter | Where-Object { $_.Name -like \"*192.168.100.0*\" }).InterfaceIndex Troubleshooting. - check if the DHCP server is running. - If that is working, then review the IP address ranges assigned to ensure they are correct and check for typos in the IP address. How to identify the IP address on a linux machine? At the prompt type. ip a Here is an example How to SSH to a Linux Machine? Use a terminal client.Putty is a good terminal to use. In Windows 11 as I have Terminal client installed I will be using this lab. But any terminal program can be used. Back to ssh from Windows terminal I will peform further configuration from the Windows Terminal as I will be able to copy and paste commands. From Windows Terminal type the following command. You will be presented with a login request. ssh -l root 192.168.100.1 Password : `123` # if the proposed Password was used DHCP is installed and SSH to alpine1 server established. Next step We will proceed with the router installation. The validation for DHCP and Internet on the private network will be tested at a later stage. Please continue with 102-alpine1-setup-router","title":"Install and Configure DHCP - alpine1"},{"location":"Document/alpine1/101-DHCP-server/#install-and-configure-dhcp-alpine1","text":"For the initial setup we will have the basic DHCP configuration. #install dhcpd apk add dhcp Update the file /etc/dhcp/dhcpd.conf with the content below. Use VI editor to edit ( or any other you are familiar with) # using console you cannot copy paste, must type in manually # create config file touch /etc/dhcp/dhcpd.conf # edit config file vi /etc/dhcp/dhcpd.conf subnet 192.168.100.0 netmask 255.255.255.0 { range 192.168.100.100 192.168.100.200; option domain-name-servers 192.168.100.1; option routers 192.168.100.1; } [esc] :x[enter] to save and exit routers : The routers IP usually is the WIFI or WAN router IP. In this lab setup we want emulate an office network setup. In the subsequent steps we will review how to setup alpine1 as a Router. domain-name-servers : in this setup we want to resolve some internal hostnames that cannot be resolved by public DNS servers. We want to have alpine1 to function as DNS server and also forward DNS request not resolved locally. The steps to configure alpine1 as DNS server is reviewed later.","title":"Install and Configure DHCP - alpine1"},{"location":"Document/alpine1/101-DHCP-server/#restart-the-dhcp-deamon","text":"To refresh the updated configuration restart the DHCP services. Any errors in configuration will appear at this point. # set dhcpd to start at boot rc-update add dhcpd default # start the dhcpd service. rc-service dhcpd start # Check the dhcpd service status. rc-service dhcpd status DHCP logs Later you may need to check if the IP addresses are assigned etc. These to files will be key for your troubleshooting. cat /etc/dhcp/dhcpd.conf cat /var/lib/dhcp/dhcpd.leases","title":"Restart the DHCP deamon"},{"location":"Document/alpine1/101-DHCP-server/#dhcp-setup-is-complete-for-alpine1-server","text":"","title":"DHCP Setup is complete  for alpine1 server ."},{"location":"Document/alpine1/101-DHCP-server/#steps-to-ssh","text":"If using DHCP, the gateway is also assigned to my Hyper-V host nic. THis caused some network issues where my connection to the internet kept timing out. When I set the IP address without the Gateway the network issues were no longer present. So better to set the IP address manualy then obtain via DHCP. Paste the following Powershell code int Windows Terminal as Administrator. $ifindex=(Get-NetAdapter | Where-Object { $_.Name -like \"*192.168.100.0*\" }).InterfaceIndex New-NetIPAddress -InterfaceIndex $ifindex -IPAddress 192.168.100.2 -PrefixLength 24 Get-DnsClient -InterfaceIndex $ifindex | Set-DnsClientServerAddress -ServerAddresses (\"192.168.100.1\") Validate Run this command on Windows Terminal to check if an IP has been assigned get-netipaddress -InterfaceIndex (Get-NetAdapter | Where-Object { $_.Name -like \"*192.168.100.0*\" }).InterfaceIndex Troubleshooting. - check if the DHCP server is running. - If that is working, then review the IP address ranges assigned to ensure they are correct and check for typos in the IP address.","title":"Steps to ssh."},{"location":"Document/alpine1/101-DHCP-server/#how-to-identify-the-ip-address-on-a-linux-machine","text":"At the prompt type. ip a Here is an example","title":"How to identify the IP address on a linux machine?"},{"location":"Document/alpine1/101-DHCP-server/#how-to-ssh-to-a-linux-machine","text":"Use a terminal client.Putty is a good terminal to use. In Windows 11 as I have Terminal client installed I will be using this lab. But any terminal program can be used. Back to ssh from Windows terminal I will peform further configuration from the Windows Terminal as I will be able to copy and paste commands. From Windows Terminal type the following command. You will be presented with a login request. ssh -l root 192.168.100.1 Password : `123` # if the proposed Password was used","title":"How to SSH to a Linux Machine?"},{"location":"Document/alpine1/101-DHCP-server/#dhcp-is-installed-and-ssh-to-alpine1-server-established","text":"","title":"DHCP is installed and SSH to alpine1 server established."},{"location":"Document/alpine1/101-DHCP-server/#next-step","text":"We will proceed with the router installation. The validation for DHCP and Internet on the private network will be tested at a later stage. Please continue with","title":"Next step"},{"location":"Document/alpine1/101-DHCP-server/#102-alpine1-setup-router","text":"","title":"102-alpine1-setup-router"},{"location":"Document/alpine1/102-setup-router/","text":"Configure as a Router - alpine1 In this setup, alpine1 will function as an internet router for the servers in the Private 192.168.100.0/24 network. This function is to allow the devices in the Private 192.168.100.0/24 network to access the internet via alpine1 . The configuration is simple. ssh to alpine1 and configure as below. # paste the following in the alpine1 ssh terminal # if you are on the Hype-V console you cannot paste the text echo \"net.ipv4.ip_forward=1\" | tee -a /etc/sysctl.conf # reload the config using sysctl -p # enable IP routing on alpine1 apk add iptables rc-update add iptables iptables -A FORWARD -i eth1 -j ACCEPT # eth0 is the external interface (connected to the internet) iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE /etc/init.d/iptables save Reference link to setup Alpine as a router Setup alpine1 server router is completed . Next step We will proceed with the DNS server installation Please continue with 103-alpine1-setup-dns","title":"Configure as a Router  -alpine1"},{"location":"Document/alpine1/102-setup-router/#configure-as-a-router-alpine1","text":"In this setup, alpine1 will function as an internet router for the servers in the Private 192.168.100.0/24 network. This function is to allow the devices in the Private 192.168.100.0/24 network to access the internet via alpine1 . The configuration is simple. ssh to alpine1 and configure as below. # paste the following in the alpine1 ssh terminal # if you are on the Hype-V console you cannot paste the text echo \"net.ipv4.ip_forward=1\" | tee -a /etc/sysctl.conf # reload the config using sysctl -p # enable IP routing on alpine1 apk add iptables rc-update add iptables iptables -A FORWARD -i eth1 -j ACCEPT # eth0 is the external interface (connected to the internet) iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE /etc/init.d/iptables save Reference link to setup Alpine as a router","title":"Configure as a Router  -alpine1"},{"location":"Document/alpine1/102-setup-router/#setup-alpine1-server-router-is-completed","text":"","title":"Setup alpine1 server router is completed ."},{"location":"Document/alpine1/102-setup-router/#next-step","text":"We will proceed with the DNS server installation Please continue with","title":"Next step"},{"location":"Document/alpine1/102-setup-router/#103-alpine1-setup-dns","text":"","title":"103-alpine1-setup-dns"},{"location":"Document/alpine1/103-setup-dns/","text":"Configure DNS server - alpine1 Install bind ( DNS server) and tools dig and nslookup on alpine1. DNS resolves Names to IP addresses. Kubetnetes will need the DNS to be closer to a production setup. Hence the requirement. This service can be skipped , but then all the connectivity will be via IP alone. In this lab we will setup bind as the DNS server application. #install bind apk add bind bind-tools # set named to start at boot rc-update add named default # check if the tools are installed. dig -v nslookup -v Configure bind with a zone and resolve internet names from the configured forwarders. # create named.conf file. touch /etc/bind/named.conf #edit named.conf file vi /etc/bind/named.conf # replace or edit the file to reflect the following. options { listen-on port 53 { 127.0.0.1; 192.168.100.1; }; forwarders { 8.8.8.8; 8.8.4.4; }; directory \"/var/bind\"; dump-file \"/var/bind/data/cache_dump.db\"; statistics-file \"/var/bind/data/named_stats.txt\"; memstatistics-file \"/var/bind/data/named_mem_stats.txt\"; allow-query { localhost; 192.168.100.0/24; }; recursion yes; }; zone \"k8s.lab\" IN { type master; file \"/etc/bind/master/k8s.lab\"; }; Next, we create the zone file. In this lab the zone name is k8s.lab # create folder and file mkdir - p /etc/bind/master/ && touch /etc/bind/master/k8s.lab # edit the file vi /etc/bind/master/k8s.lab # paste following $TTL 38400 @ IN SOA ns.k8s.lab admin.k8s.lab. ( 2 ;Serial 600 ;Refresh 300 ;Retry 60480 ;Expire 600 ) ;Negative Cache TTL @ IN NS ns1.k8s.lab. ns1 IN A 192.168.100.1 alpine1 IN A 192.168.100.1 k8s-ha-cluster IN A 192.168.100.201 loadbalancer IN A 192.168.100.201 master1 IN A 192.168.100.202 master2 IN A 192.168.100.203 master3 IN A 192.168.100.204 worker1 IN A 192.168.100.205 worker2 IN A 192.168.100.206 worker3 IN A 192.168.100.207 single IN A 192.168.100.199 singleubuntu IN A 192.168.100.198 Validate the bind configuration # check if the formating is correct named-checkconf /etc/bind/named.conf # (re)start bind service. ( the service name is 'named') rc-service named restart # ensure no errors are returned Validate DNS. To validate you need to run nslookup on a remote server. As there are no other servers setup, this can be validated when the VM's are created. To ensure alpine1 resolves the FQDN's correctly ensure the following is configured # run command to check Network interface configuration vi /etc/network/interfaces auto lo iface lo inet loopback auto eth0 iface eth0 inet dhcp auto eth1 iface eth1 inet static address 192.168.100.1 netmask 255.255.255.0 ## ensure the following 2 rows are added. dns-search k8s.lab dns-nameservers 192.168.100.1 #on alpine1 only. vi /etc/resolve nameserver 192.168.100.1 search k8s.lab #in my case the every time the alpine1 is rebooted the values in this file get reset. # as such the following is to set the immutable flag #enables readonly chattr +i /etc/resolv.conf #disables readonly chattr -i /etc/resolv.conf Setup alpine1 server DNS is complete. Next step We will proceed with the nginx server installation Please continue with 104-alpine1-setup-nginx","title":"Configure DNS server - alpine1"},{"location":"Document/alpine1/103-setup-dns/#configure-dns-server-alpine1","text":"","title":"Configure DNS server - alpine1"},{"location":"Document/alpine1/103-setup-dns/#install-bind-dns-server-and-tools-dig-and-nslookup-on-alpine1","text":"DNS resolves Names to IP addresses. Kubetnetes will need the DNS to be closer to a production setup. Hence the requirement. This service can be skipped , but then all the connectivity will be via IP alone. In this lab we will setup bind as the DNS server application. #install bind apk add bind bind-tools # set named to start at boot rc-update add named default # check if the tools are installed. dig -v nslookup -v Configure bind with a zone and resolve internet names from the configured forwarders. # create named.conf file. touch /etc/bind/named.conf #edit named.conf file vi /etc/bind/named.conf # replace or edit the file to reflect the following. options { listen-on port 53 { 127.0.0.1; 192.168.100.1; }; forwarders { 8.8.8.8; 8.8.4.4; }; directory \"/var/bind\"; dump-file \"/var/bind/data/cache_dump.db\"; statistics-file \"/var/bind/data/named_stats.txt\"; memstatistics-file \"/var/bind/data/named_mem_stats.txt\"; allow-query { localhost; 192.168.100.0/24; }; recursion yes; }; zone \"k8s.lab\" IN { type master; file \"/etc/bind/master/k8s.lab\"; }; Next, we create the zone file. In this lab the zone name is k8s.lab # create folder and file mkdir - p /etc/bind/master/ && touch /etc/bind/master/k8s.lab # edit the file vi /etc/bind/master/k8s.lab # paste following $TTL 38400 @ IN SOA ns.k8s.lab admin.k8s.lab. ( 2 ;Serial 600 ;Refresh 300 ;Retry 60480 ;Expire 600 ) ;Negative Cache TTL @ IN NS ns1.k8s.lab. ns1 IN A 192.168.100.1 alpine1 IN A 192.168.100.1 k8s-ha-cluster IN A 192.168.100.201 loadbalancer IN A 192.168.100.201 master1 IN A 192.168.100.202 master2 IN A 192.168.100.203 master3 IN A 192.168.100.204 worker1 IN A 192.168.100.205 worker2 IN A 192.168.100.206 worker3 IN A 192.168.100.207 single IN A 192.168.100.199 singleubuntu IN A 192.168.100.198 Validate the bind configuration # check if the formating is correct named-checkconf /etc/bind/named.conf # (re)start bind service. ( the service name is 'named') rc-service named restart # ensure no errors are returned Validate DNS. To validate you need to run nslookup on a remote server. As there are no other servers setup, this can be validated when the VM's are created. To ensure alpine1 resolves the FQDN's correctly ensure the following is configured # run command to check Network interface configuration vi /etc/network/interfaces auto lo iface lo inet loopback auto eth0 iface eth0 inet dhcp auto eth1 iface eth1 inet static address 192.168.100.1 netmask 255.255.255.0 ## ensure the following 2 rows are added. dns-search k8s.lab dns-nameservers 192.168.100.1 #on alpine1 only. vi /etc/resolve nameserver 192.168.100.1 search k8s.lab #in my case the every time the alpine1 is rebooted the values in this file get reset. # as such the following is to set the immutable flag #enables readonly chattr +i /etc/resolv.conf #disables readonly chattr -i /etc/resolv.conf","title":"Install bind ( DNS server) and tools dig and nslookup on alpine1."},{"location":"Document/alpine1/103-setup-dns/#setup-alpine1-server-dns-is-complete","text":"","title":"Setup alpine1 server DNS is complete."},{"location":"Document/alpine1/103-setup-dns/#next-step","text":"We will proceed with the nginx server installation Please continue with","title":"Next step"},{"location":"Document/alpine1/103-setup-dns/#104-alpine1-setup-nginx","text":"","title":"104-alpine1-setup-nginx"},{"location":"Document/alpine1/104-setup-nginx/","text":"Install and Configure nginx - alpine1 A webserver is handy for several reasons. In this Lab we will use a webserver for quite a bit of stuff. Lets set up nginx for this purpose. #install nginx apk update apk add nginx # set nginx to start at boot rc-update add nginx default #check nginx service status rc-service nginx status # start nginx service rc-service nginx start #nginx configuration # no change required in this lab setup vi /etc/nginx/nginx.conf Configure a new site to list the files over http. # nginx installs with a default site # this site will intefere with the new site we are setting up. # remove default site rm /etc/nginx/http.d/default.conf # create a file for the site . vi /etc/nginx/http.d/installfileserver.conf # paste the following code. server { server_name localhost; root /srv/; #index index.html; location / { # new url path # this is the URL path on browser alias /srv/; # directory to list #in this case http://ip/ will list files in \"/srv/\" # this might not be best practice, but this is a Lab setup autoindex on; } } Check nginx config after every change for errors #check syntax nginx -t #reload nginx rc-service nginx restart Logs You can check the files accessed via url, this way you can validate if the correct paths are in place. cat /var/log/nginx/access.log Validate # create a file to be listed mkdir -p /srv/autoinstall/ && touch /srv/autoinstall/test.txt #In a browser open the following URL http://192.168.100.1 The list of files hosted in `/srv/autoinstall/` will be listed. Here is and example Setup alpine1 server nginx is complete. Next step We will proceed with the nfs server installation Please continue with 105-alpine1-nfs","title":"Install and Configure nginx - alpine1"},{"location":"Document/alpine1/104-setup-nginx/#install-and-configure-nginx-alpine1","text":"A webserver is handy for several reasons. In this Lab we will use a webserver for quite a bit of stuff. Lets set up nginx for this purpose. #install nginx apk update apk add nginx # set nginx to start at boot rc-update add nginx default #check nginx service status rc-service nginx status # start nginx service rc-service nginx start #nginx configuration # no change required in this lab setup vi /etc/nginx/nginx.conf Configure a new site to list the files over http. # nginx installs with a default site # this site will intefere with the new site we are setting up. # remove default site rm /etc/nginx/http.d/default.conf # create a file for the site . vi /etc/nginx/http.d/installfileserver.conf # paste the following code. server { server_name localhost; root /srv/; #index index.html; location / { # new url path # this is the URL path on browser alias /srv/; # directory to list #in this case http://ip/ will list files in \"/srv/\" # this might not be best practice, but this is a Lab setup autoindex on; } } Check nginx config after every change for errors #check syntax nginx -t #reload nginx rc-service nginx restart Logs You can check the files accessed via url, this way you can validate if the correct paths are in place. cat /var/log/nginx/access.log Validate # create a file to be listed mkdir -p /srv/autoinstall/ && touch /srv/autoinstall/test.txt #In a browser open the following URL http://192.168.100.1 The list of files hosted in `/srv/autoinstall/` will be listed. Here is and example","title":"Install and Configure nginx - alpine1"},{"location":"Document/alpine1/104-setup-nginx/#setup-alpine1-server-nginx-is-complete","text":"","title":"Setup alpine1 server nginx is complete."},{"location":"Document/alpine1/104-setup-nginx/#next-step","text":"We will proceed with the nfs server installation Please continue with","title":"Next step"},{"location":"Document/alpine1/104-setup-nginx/#105-alpine1-nfs","text":"","title":"105-alpine1-nfs"},{"location":"Document/alpine1/105-nfs/","text":"Install and Configure nfs - alpine1 nfs functions as a remote Hard Disk. If you need to access files locally but are stored on a remote server shared using nfs then this nfs will behave as its a Hard Disk setup locally. We do have use cases for nfs so lets set this up. # in this lab we will mount the ubuntu ISO to be served via nfs. # the first part will be to mount the ubuntu ISO files to a folder. # create the folder to download the iso file to. mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso #Create folder to mount ISO file mkdir -p /srv/isoubuntu # this will mount the ISO file until the server is rebooted mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu ls /srv/isoubuntu # to make the iso mounted permanantly # update the fstab vi /etc/fstab #add following entry /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu iso9660 loop 0 0 Validate by rebooting the server and check if the iso files are listed. ls /srv/isoubuntu #install nfs apk update apk add nfs-utils # set nfs to start at boot rc-update add nfs # check status rc-service nfs status # start nfs service rc-service rpcbind start rc-service nfs start #### revalidate config and validation #nfs configuration # update file with the entry below. vi /etc/exports /srv/isoubuntu 192.168.100.1/24(async,ro,no_subtree_check,no_root_squash) # refresh the nfs with the updated row. exportfs -arv #test mount using the following command mkdir mntnfs mount 192.168.100.1:/srv/isoubuntu mntnfs # List files in mount ls mntnfs/ Setup alpine1 nfs is complete. Next step We will proceed with the tftp server installation Please continue with 106-alpine1-tftp","title":"Install and Configure nfs- alpine1"},{"location":"Document/alpine1/105-nfs/#install-and-configure-nfs-alpine1","text":"nfs functions as a remote Hard Disk. If you need to access files locally but are stored on a remote server shared using nfs then this nfs will behave as its a Hard Disk setup locally. We do have use cases for nfs so lets set this up. # in this lab we will mount the ubuntu ISO to be served via nfs. # the first part will be to mount the ubuntu ISO files to a folder. # create the folder to download the iso file to. mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso #Create folder to mount ISO file mkdir -p /srv/isoubuntu # this will mount the ISO file until the server is rebooted mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu ls /srv/isoubuntu # to make the iso mounted permanantly # update the fstab vi /etc/fstab #add following entry /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu iso9660 loop 0 0 Validate by rebooting the server and check if the iso files are listed. ls /srv/isoubuntu #install nfs apk update apk add nfs-utils # set nfs to start at boot rc-update add nfs # check status rc-service nfs status # start nfs service rc-service rpcbind start rc-service nfs start #### revalidate config and validation #nfs configuration # update file with the entry below. vi /etc/exports /srv/isoubuntu 192.168.100.1/24(async,ro,no_subtree_check,no_root_squash) # refresh the nfs with the updated row. exportfs -arv #test mount using the following command mkdir mntnfs mount 192.168.100.1:/srv/isoubuntu mntnfs # List files in mount ls mntnfs/","title":"Install and Configure nfs- alpine1"},{"location":"Document/alpine1/105-nfs/#setup-alpine1-nfs-is-complete","text":"","title":"Setup alpine1 nfs is complete."},{"location":"Document/alpine1/105-nfs/#next-step","text":"We will proceed with the tftp server installation Please continue with","title":"Next step"},{"location":"Document/alpine1/105-nfs/#106-alpine1-tftp","text":"","title":"106-alpine1-tftp"},{"location":"Document/alpine1/106-tftp/","text":"Install and Configure tftpd - alpine1 tftp is required for PXELINUX boot setup. This is how the initial boot files are retrieved from the remote client. # create directories mkdir /srv/tftp/ #install tftpd apk update apk add tftp-hpa # set nginx to start at boot rc-update add in.tftpd # Update in.tftpd configuration vi /etc/conf.d/in.tftpd #change or update row to reflect the path /srv/tftp/ INTFTPD_PATH=\"/srv/tftp/\" #check in.tftpd service status rc-service in.tftpd status #Start service now rc-service in.tftpd start The path /srv/tftp/ is important to note as the subsequent configuration will use this folder as root. Next step We will proceed with the cloud-init installation Please continue with 107-alpine1-cloud-init","title":"Install and Configure tftpd - alpine1"},{"location":"Document/alpine1/106-tftp/#install-and-configure-tftpd-alpine1","text":"tftp is required for PXELINUX boot setup. This is how the initial boot files are retrieved from the remote client. # create directories mkdir /srv/tftp/ #install tftpd apk update apk add tftp-hpa # set nginx to start at boot rc-update add in.tftpd # Update in.tftpd configuration vi /etc/conf.d/in.tftpd #change or update row to reflect the path /srv/tftp/ INTFTPD_PATH=\"/srv/tftp/\" #check in.tftpd service status rc-service in.tftpd status #Start service now rc-service in.tftpd start The path /srv/tftp/ is important to note as the subsequent configuration will use this folder as root.","title":"Install and Configure tftpd - alpine1"},{"location":"Document/alpine1/106-tftp/#next-step","text":"We will proceed with the cloud-init installation Please continue with","title":"Next step"},{"location":"Document/alpine1/106-tftp/#107-alpine1-cloud-init","text":"","title":"107-alpine1-cloud-init"},{"location":"Document/alpine1/107-cloud-init/","text":"Install and Configure cloud-init - alpine1 cloud-init is the application that reads the user-data script as part of autoinstallation. As I have been having issues with my user-data I needed a method to validate the content. Turns out cloud-init has a command for just that! # enable community repository vi /etc/apk/repositories remove # from the row #http://mirror.jingk.ai/alpine/v3.18/community #install `cloud-init` apk update apk add cloud-init #setup cloud-init setup-cloud-init Validate user-data using the command below. At this time the lab has not generated the user-data file . You can test this if you have a user-data file handy. The user-data will be shared in later steps cloud-init schema --config-file user-data My error was to put in an entry for remark that was not recognized. Next step We will proceed with the DHCP setup for PXE requirements. Please continue with 108-alpine1-DHCP-for-PXE","title":"Install and Configure cloud-init - alpine1"},{"location":"Document/alpine1/107-cloud-init/#install-and-configure-cloud-init-alpine1","text":"cloud-init is the application that reads the user-data script as part of autoinstallation. As I have been having issues with my user-data I needed a method to validate the content. Turns out cloud-init has a command for just that! # enable community repository vi /etc/apk/repositories remove # from the row #http://mirror.jingk.ai/alpine/v3.18/community #install `cloud-init` apk update apk add cloud-init #setup cloud-init setup-cloud-init Validate user-data using the command below. At this time the lab has not generated the user-data file . You can test this if you have a user-data file handy. The user-data will be shared in later steps cloud-init schema --config-file user-data My error was to put in an entry for remark that was not recognized.","title":"Install and Configure cloud-init - alpine1"},{"location":"Document/alpine1/107-cloud-init/#next-step","text":"We will proceed with the DHCP setup for PXE requirements. Please continue with","title":"Next step"},{"location":"Document/alpine1/107-cloud-init/#108-alpine1-dhcp-for-pxe","text":"","title":"108-alpine1-DHCP-for-PXE"},{"location":"Document/alpine1/108-DHCP-for-PXE/","text":"update DHCP options to provide PXE boot information to clients. - alpine1 The initial DHCP was to provide IP addresses to remote clients. As we now want to provide the scope options for the tftp servers with the boot file location, lets make the following changes. Update the dhcpd.conf as follows. vi /etc/dhcp/dhcpd.conf subnet 192.168.100.0 netmask 255.255.255.0 { range 192.168.100.50 192.168.100.100; option routers 192.168.100.1; option domain-name-servers 192.168.100.1; option time-servers 192.168.100.1; option ntp-servers 192.168.100.1; # next-server 192.168.100.1; # this is typically if the tftp is on another server. if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00000\" { filename \"bios/pxelinux.0\"; } if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00007\" { filename \"efi64/syslinux.efi\"; } #assign IP based on MAC address # if you have a need to setup DHCP for specific hosts host someserver { hardware ethernet 00:15:5d:00:8a:3d; # change to your MAC address. fixed-address 192.168.100.250; option host-name \"someserver\"; } } Restart the dhcp service. rc-service dhcpd restart Validation At this stage we cannot perform test to validate if this works. This is because we have not setup the files for the boot process. Lets defer the test after the boot files have been setup. Next step We will proceed with the DHCP setup for PXE requirements. Please continue with 108-alpine1-DHCP-for-PXE","title":"update DHCP options to provide PXE boot information to clients. - alpine1"},{"location":"Document/alpine1/108-DHCP-for-PXE/#update-dhcp-options-to-provide-pxe-boot-information-to-clients-alpine1","text":"The initial DHCP was to provide IP addresses to remote clients. As we now want to provide the scope options for the tftp servers with the boot file location, lets make the following changes. Update the dhcpd.conf as follows. vi /etc/dhcp/dhcpd.conf subnet 192.168.100.0 netmask 255.255.255.0 { range 192.168.100.50 192.168.100.100; option routers 192.168.100.1; option domain-name-servers 192.168.100.1; option time-servers 192.168.100.1; option ntp-servers 192.168.100.1; # next-server 192.168.100.1; # this is typically if the tftp is on another server. if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00000\" { filename \"bios/pxelinux.0\"; } if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00007\" { filename \"efi64/syslinux.efi\"; } #assign IP based on MAC address # if you have a need to setup DHCP for specific hosts host someserver { hardware ethernet 00:15:5d:00:8a:3d; # change to your MAC address. fixed-address 192.168.100.250; option host-name \"someserver\"; } } Restart the dhcp service. rc-service dhcpd restart Validation At this stage we cannot perform test to validate if this works. This is because we have not setup the files for the boot process. Lets defer the test after the boot files have been setup.","title":"update DHCP options to provide PXE boot information to clients. - alpine1"},{"location":"Document/alpine1/108-DHCP-for-PXE/#next-step","text":"We will proceed with the DHCP setup for PXE requirements. Please continue with","title":"Next step"},{"location":"Document/alpine1/108-DHCP-for-PXE/#108-alpine1-dhcp-for-pxe","text":"","title":"108-alpine1-DHCP-for-PXE"},{"location":"Document/alpine1/109-setup-boot-files-part1/","text":"Part 1 of 4 Setup boot files for PXELINUX and OS boot - alpine1 When a new computer starts up in the network it needs a set of boot files that provide instructions. In this lab setup ( an also production setups) we want to present a boot menu. With this menu, we can then have options to perform multiple tasks. In this case we can have flavours of Operating Systems. Including MS Windows OS deployment. This lab will review the Ubuntu OS deployment. This There are 2 sets of boot files required, PXELINUX boot files and Remote client OS Boot files PXELINUX boot files It is a good time to highlight there are 2 types of boot process, BIOS and EFI . BIOS is for older Computers. The newer computers work with EFI . This was confusing initialy as the SYSLINUX files actually have versions specific to BIOS , EFI32 and EFI64 . In Hyper-V when you create a VM you are given a choice of Generation 1 or Generation 2 . If you selected Generation 1 then you need to use the BIOS version. In this lab Generation 2 was selected when the VM's are created. The BIOS version is stated here to provide this fact that could have saved me a lot of time. The BIOS version is not tested. This boot file is delivered via tftp. Lets review the files required. BIOS Core files pxelinux.0 ldlinux.c32 Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 EFI64 Core files ldlinux.e64 syslinux.efi Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 Where to get these files? The files can be downloaded from SYSLINUX ver 6.03 The SYSLINUX has many files, in this lab we will extract the relevant files required. This will be shared in Part 2. Remote client OS boot files. The next set of Boot files are the OS boot files. For example these can be Ubuntu, Debian, Microsoft Windows boot files. In this example we will extract the boot files from the Ubuntu ISO LiveCD. For Linux the boot files required are. vmlinuz initrd The file name can also include the version is some cases, but the base file names will still be present. Completion of Boot file background. Some background was neccasary before proceeding with the boot file preparation. Hopefully provides more clarity. Next step We will proceed with the preparation of the boot files. Please continue with 110-alpine1-setup-boot-files-part2-PXE","title":"Part 1 of 4  Setup boot files for PXELINUX and OS boot- alpine1"},{"location":"Document/alpine1/109-setup-boot-files-part1/#part-1-of-4-setup-boot-files-for-pxelinux-and-os-boot-alpine1","text":"When a new computer starts up in the network it needs a set of boot files that provide instructions. In this lab setup ( an also production setups) we want to present a boot menu. With this menu, we can then have options to perform multiple tasks. In this case we can have flavours of Operating Systems. Including MS Windows OS deployment. This lab will review the Ubuntu OS deployment. This There are 2 sets of boot files required, PXELINUX boot files and Remote client OS Boot files","title":"Part 1 of 4  Setup boot files for PXELINUX and OS boot- alpine1"},{"location":"Document/alpine1/109-setup-boot-files-part1/#pxelinux-boot-files","text":"It is a good time to highlight there are 2 types of boot process, BIOS and EFI . BIOS is for older Computers. The newer computers work with EFI . This was confusing initialy as the SYSLINUX files actually have versions specific to BIOS , EFI32 and EFI64 . In Hyper-V when you create a VM you are given a choice of Generation 1 or Generation 2 . If you selected Generation 1 then you need to use the BIOS version. In this lab Generation 2 was selected when the VM's are created. The BIOS version is stated here to provide this fact that could have saved me a lot of time. The BIOS version is not tested. This boot file is delivered via tftp. Lets review the files required.","title":"PXELINUX boot files"},{"location":"Document/alpine1/109-setup-boot-files-part1/#bios-core-files","text":"pxelinux.0 ldlinux.c32 Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32","title":"BIOS Core files"},{"location":"Document/alpine1/109-setup-boot-files-part1/#efi64-core-files","text":"ldlinux.e64 syslinux.efi Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32","title":"EFI64 Core files"},{"location":"Document/alpine1/109-setup-boot-files-part1/#where-to-get-these-files","text":"The files can be downloaded from SYSLINUX ver 6.03 The SYSLINUX has many files, in this lab we will extract the relevant files required. This will be shared in Part 2.","title":"Where to get these files?"},{"location":"Document/alpine1/109-setup-boot-files-part1/#remote-client-os-boot-files","text":"The next set of Boot files are the OS boot files. For example these can be Ubuntu, Debian, Microsoft Windows boot files. In this example we will extract the boot files from the Ubuntu ISO LiveCD. For Linux the boot files required are. vmlinuz initrd The file name can also include the version is some cases, but the base file names will still be present.","title":"Remote client OS boot files."},{"location":"Document/alpine1/109-setup-boot-files-part1/#completion-of-boot-file-background","text":"Some background was neccasary before proceeding with the boot file preparation. Hopefully provides more clarity.","title":"Completion of Boot file background."},{"location":"Document/alpine1/109-setup-boot-files-part1/#next-step","text":"We will proceed with the preparation of the boot files. Please continue with","title":"Next step"},{"location":"Document/alpine1/109-setup-boot-files-part1/#110-alpine1-setup-boot-files-part2-pxe","text":"","title":"110-alpine1-setup-boot-files-part2-PXE"},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/","text":"Part 2 of 4 Setup boot files for PXELINUX - alpine1 The boot files are separated by the type of Boot process BIOS and EFI Take note the files while have duplicate names, there are separate versions for BIOS and EFI . TFTP Directory and content (/srv/tftp/bios) pxelinux.0 ldlinux.c32 menu.c32 libutil.c32 vesamenu.c32 libcom32.c32 pxelinux.cfg\\default (/srv/tftp/efi64) ldlinux.e64 syslinux.efi menu.c32 libutil.c32 vesamenu.c32 libcom32.c32 pxelinux.cfg\\default SYSLINUX files. To extract the relevant files can be quite an effort to explain, I have compiled the required files. syslinux-6.04-pre1-PXE-specific.tar Copy files to tftp folder. The folder configure in the DHCP is efi64/syslinux.efi and bios/pxelinux.0 this is with the tftp as the root folder. # Download file wget https://<URL>/syslinux-6.04-pre1-PXE-specific.tar #extract file tar --strip-components=1 -xvf syslinux-6.04-pre1-PXE-specific.tar -C /srv/tftp Validate ls /srv/tftp/syslinux-6.04-pre1-PXE-specific Here is the tftp folder after extraction. Take note of the the EFI64 and BIOS folders Next step We will proceed with the preparation of the OS boot files. Continue with 111-alpine1-setup-boot-files-part3-OS","title":"Part 2 of 4  Setup boot files for PXELINUX - alpine1"},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/#part-2-of-4-setup-boot-files-for-pxelinux-alpine1","text":"The boot files are separated by the type of Boot process BIOS and EFI Take note the files while have duplicate names, there are separate versions for BIOS and EFI .","title":"Part 2 of 4  Setup boot files for PXELINUX - alpine1"},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/#tftp-directory-and-content","text":"(/srv/tftp/bios) pxelinux.0 ldlinux.c32 menu.c32 libutil.c32 vesamenu.c32 libcom32.c32 pxelinux.cfg\\default (/srv/tftp/efi64) ldlinux.e64 syslinux.efi menu.c32 libutil.c32 vesamenu.c32 libcom32.c32 pxelinux.cfg\\default","title":"TFTP Directory and content"},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/#syslinux-files","text":"To extract the relevant files can be quite an effort to explain, I have compiled the required files. syslinux-6.04-pre1-PXE-specific.tar","title":"SYSLINUX files."},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/#copy-files-to-tftp-folder","text":"The folder configure in the DHCP is efi64/syslinux.efi and bios/pxelinux.0 this is with the tftp as the root folder. # Download file wget https://<URL>/syslinux-6.04-pre1-PXE-specific.tar #extract file tar --strip-components=1 -xvf syslinux-6.04-pre1-PXE-specific.tar -C /srv/tftp","title":"Copy files to tftp folder."},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/#validate","text":"ls /srv/tftp/syslinux-6.04-pre1-PXE-specific Here is the tftp folder after extraction. Take note of the the EFI64 and BIOS folders","title":"Validate"},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/#next-step","text":"We will proceed with the preparation of the OS boot files. Continue with","title":"Next step"},{"location":"Document/alpine1/110-setup-boot-files-part2-PXE/#111-alpine1-setup-boot-files-part3-os","text":"","title":"111-alpine1-setup-boot-files-part3-OS"},{"location":"Document/alpine1/111-setup-boot-files-part3-OS/","text":"Part 3 of 4 Setup OS Boot files - alpine1 In this section we will perform 2 tasks - Download and mount the ISO Live CD. - Extract the vmlinuz and initrd files from the LiveCD to the tftp folder Download and mount the ISO Live CD. Boot files. When booting a Server with Linux, there are 2 files required. vmlinuz and initrd at times the version is part of the name depending on Linux flavors In this example boot files are retrieved from ubuntu-20.04.6-live-server-amd64.iso Step 1 Download and Mount the ISO. # lets host the ISO in the folder /iso mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso # Create mount folder mkdir -p /srv/isoubuntu # mount the ISO to view contents. mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu # list content to validate ls /srv/isoubuntu Validate if accessible via HTTP As we have already setup nginx to list directory content. This should be visible via browser. Click tftp and iso to list the ISO LiveCD. Step 2 Extract vmlinuz and initrd Run the commands below to extract the boot files. #create ubuntu folder to store the boot files. # this way we can have boot files for multple distros if required. mkdir -p /srv/tftp/ubuntu/casper # copy files cp /srv/isoubuntu/casper/vmlinuz /srv/tftp/ubuntu/casper cp /srv/isoubuntu/casper/initrd /srv/tftp/ubuntu/casper Validate The boot files will be served via http. Do validate if this folder and content is listed. ## Next step At this stage we have made all the required files available for the boot process. Next we will put in the final piece for the setup to function. 112-alpine1-setup-boot-files-part4-pxelinux.cfg","title":"Part 3 of 4 Setup OS Boot files - alpine1"},{"location":"Document/alpine1/111-setup-boot-files-part3-OS/#part-3-of-4-setup-os-boot-files-alpine1","text":"In this section we will perform 2 tasks - Download and mount the ISO Live CD. - Extract the vmlinuz and initrd files from the LiveCD to the tftp folder","title":"Part 3 of 4 Setup OS Boot files - alpine1"},{"location":"Document/alpine1/111-setup-boot-files-part3-OS/#download-and-mount-the-iso-live-cd","text":"","title":"Download and mount the ISO Live CD."},{"location":"Document/alpine1/111-setup-boot-files-part3-OS/#boot-files","text":"When booting a Server with Linux, there are 2 files required. vmlinuz and initrd at times the version is part of the name depending on Linux flavors In this example boot files are retrieved from ubuntu-20.04.6-live-server-amd64.iso","title":"Boot files."},{"location":"Document/alpine1/111-setup-boot-files-part3-OS/#step-1-download-and-mount-the-iso","text":"# lets host the ISO in the folder /iso mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso # Create mount folder mkdir -p /srv/isoubuntu # mount the ISO to view contents. mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu # list content to validate ls /srv/isoubuntu Validate if accessible via HTTP As we have already setup nginx to list directory content. This should be visible via browser. Click tftp and iso to list the ISO LiveCD.","title":"Step 1 Download and Mount the ISO."},{"location":"Document/alpine1/111-setup-boot-files-part3-OS/#step-2-extract-vmlinuz-and-initrd","text":"Run the commands below to extract the boot files. #create ubuntu folder to store the boot files. # this way we can have boot files for multple distros if required. mkdir -p /srv/tftp/ubuntu/casper # copy files cp /srv/isoubuntu/casper/vmlinuz /srv/tftp/ubuntu/casper cp /srv/isoubuntu/casper/initrd /srv/tftp/ubuntu/casper Validate The boot files will be served via http. Do validate if this folder and content is listed. ## Next step At this stage we have made all the required files available for the boot process. Next we will put in the final piece for the setup to function.","title":"Step 2 Extract vmlinuz and initrd"},{"location":"Document/alpine1/111-setup-boot-files-part3-OS/#112-alpine1-setup-boot-files-part4-pxelinuxcfg","text":"","title":"112-alpine1-setup-boot-files-part4-pxelinux.cfg"},{"location":"Document/alpine1/112-setup-boot-files-part4-pxelinux.cfg/","text":"Part 4 of 4 Configure the boot menu pxelinux.cfg/default - alpine1 The final piece is to prepare the boot menu to load and present a selection that will install the Ubuntu OS. The syslinux-6.04-pre1-PXE-specific.tar already contains the pxelinux.cfg/default that is working. Lets do this manually. Validate the file content of pxelinux.cfg/default matches the code below. vi /srv/tftp/efi64/pxelinux.cfg/default DEFAULT Bootlocal TIMEOUT 50 UI vesamenu.c32 MENU RESOLUTION 1024 768 MENU BACKGROUND splash/pine-green-splash.png MENU TITLE PXE Boot Menu LABEL ubuntu-iso-remote #iso downloaded from http. Requires 4GB of Memory MENU LABEL ubuntu-iso-remote (iso downloaded - 4GB Memory) KERNEL http://192.168.100.1/tftp/ubuntu/casper/vmlinuz INITRD http://192.168.100.1/tftp/ubuntu/casper/initrd append url=http://192.168.100.1/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstall/ ip=dhcp fsck.mode=skip --- LABEL ubuntu-DVD-local (Ubuntu DVD locally mounted - 1GB Memory) MENU LABEL ubuntu-iso-local (iso locally mounted 1GB of Memory) KERNEL http://192.168.100.1/tftp/ubuntu/casper/vmlinuz INITRD http://192.168.100.1/tftp/ubuntu/casper/initrd APPEND autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstall/ ip=dhcp fsck.mode=skip --- LABEL ubuntu-nfs-boot (Ubuntu iso mounted on nfs - 1GB Memory) MENU LABEL ubuntu-iso-local (iso locally mounted 1GB of Memory) KERNEL http://192.168.100.1/tftp/ubuntu/casper/vmlinuz INITRD http://192.168.100.1/tftp/ubuntu/casper/initrd APPEND netboot=nfs boot=casper root=/dev/nfs nfsroot=192.168.100.1:/srv/isoubuntu autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstall/ ip=dhcp fsck.mode=skip --- LABEL Bootlocal MENU LABEL Bootlocal LOCALBOOT 0 With the above configuration in place, a remote server in the Private 192.168.100.0/24 network that has Network boot configured will be able to boot successfully. What happens next? When the remote client boots, it will get the DHCP options for the tftp`` server. The syslinux.efi` will load and then present the boot menu. Choosing either option will present with the Ubuntu install window. The usual process to setup can now continue. ## Troubleshooting steps. As I performed the configuration, I faced some issues , and the following had configuration errors mostly. i.e. wrong IP, typos etc. - Check DHCP Check the logs to see if the IP is being assigned. If it does not it could be a network related configuration. - Check nginx If a URL is part of the process, check the nginx access logs for reference to queries to the specific url. - ensure VM has minimum 4GB of memory to load the Ubuntu OS setup. This is for the ISO to be extracted to memory. - URL path incorrect. - the selection of ubuntu-iso-local`` is actualy looking at for the ISO to be mounted locally. The files are not loaded from nfs`. Next step THe PXE boot to install Ubuntu is now complete. If you are looking to automate the entries for the Ubuntu installation, the next step will review the relevant points. 113-New-VM-setup-Ubuntu-autoinstall","title":"Part 4 of 4 Configure the boot menu pxelinux.cfg/default - alpine1"},{"location":"Document/alpine1/112-setup-boot-files-part4-pxelinux.cfg/#part-4-of-4-configure-the-boot-menu-pxelinuxcfgdefault-alpine1","text":"The final piece is to prepare the boot menu to load and present a selection that will install the Ubuntu OS. The syslinux-6.04-pre1-PXE-specific.tar already contains the pxelinux.cfg/default that is working. Lets do this manually. Validate the file content of pxelinux.cfg/default matches the code below. vi /srv/tftp/efi64/pxelinux.cfg/default DEFAULT Bootlocal TIMEOUT 50 UI vesamenu.c32 MENU RESOLUTION 1024 768 MENU BACKGROUND splash/pine-green-splash.png MENU TITLE PXE Boot Menu LABEL ubuntu-iso-remote #iso downloaded from http. Requires 4GB of Memory MENU LABEL ubuntu-iso-remote (iso downloaded - 4GB Memory) KERNEL http://192.168.100.1/tftp/ubuntu/casper/vmlinuz INITRD http://192.168.100.1/tftp/ubuntu/casper/initrd append url=http://192.168.100.1/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstall/ ip=dhcp fsck.mode=skip --- LABEL ubuntu-DVD-local (Ubuntu DVD locally mounted - 1GB Memory) MENU LABEL ubuntu-iso-local (iso locally mounted 1GB of Memory) KERNEL http://192.168.100.1/tftp/ubuntu/casper/vmlinuz INITRD http://192.168.100.1/tftp/ubuntu/casper/initrd APPEND autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstall/ ip=dhcp fsck.mode=skip --- LABEL ubuntu-nfs-boot (Ubuntu iso mounted on nfs - 1GB Memory) MENU LABEL ubuntu-iso-local (iso locally mounted 1GB of Memory) KERNEL http://192.168.100.1/tftp/ubuntu/casper/vmlinuz INITRD http://192.168.100.1/tftp/ubuntu/casper/initrd APPEND netboot=nfs boot=casper root=/dev/nfs nfsroot=192.168.100.1:/srv/isoubuntu autoinstall ds=nocloud-net;s=http://192.168.100.1/autoinstall/ ip=dhcp fsck.mode=skip --- LABEL Bootlocal MENU LABEL Bootlocal LOCALBOOT 0 With the above configuration in place, a remote server in the Private 192.168.100.0/24 network that has Network boot configured will be able to boot successfully.","title":"Part 4 of 4 Configure the boot menu pxelinux.cfg/default - alpine1"},{"location":"Document/alpine1/112-setup-boot-files-part4-pxelinux.cfg/#what-happens-next","text":"When the remote client boots, it will get the DHCP options for the tftp`` server. The syslinux.efi` will load and then present the boot menu. Choosing either option will present with the Ubuntu install window. The usual process to setup can now continue. ## Troubleshooting steps. As I performed the configuration, I faced some issues , and the following had configuration errors mostly. i.e. wrong IP, typos etc. - Check DHCP Check the logs to see if the IP is being assigned. If it does not it could be a network related configuration. - Check nginx If a URL is part of the process, check the nginx access logs for reference to queries to the specific url. - ensure VM has minimum 4GB of memory to load the Ubuntu OS setup. This is for the ISO to be extracted to memory. - URL path incorrect. - the selection of ubuntu-iso-local`` is actualy looking at for the ISO to be mounted locally. The files are not loaded from nfs`.","title":"What happens next?"},{"location":"Document/alpine1/112-setup-boot-files-part4-pxelinux.cfg/#next-step","text":"THe PXE boot to install Ubuntu is now complete. If you are looking to automate the entries for the Ubuntu installation, the next step will review the relevant points.","title":"Next step"},{"location":"Document/alpine1/112-setup-boot-files-part4-pxelinux.cfg/#113-new-vm-setup-ubuntu-autoinstall","text":"","title":"113-New-VM-setup-Ubuntu-autoinstall"},{"location":"Document/draft/200-setup-alpine-LB/","text":"Setup Alpine Load balancer Setup-alpine hostname IP address alpineLB 192.168.33.201/24 Install alpine Key information Alpine Default login login : root password : blank Hyper-V configuration for reference Alpine install ISO first boot Disable IPv6 on Alpine In my setup IPv6 was not workinging if you have issues with IPv6, do disable before proceeding. Edit the /etc/sysctl.conf vi /etc/sysctl.conf # Manualy type in the following # press [i] to be in insert /edit mode net.ipv6.conf.all.disable_ipv6 = 1 # to save and exit following key press # [esc] :x! [enter] # reload the configuration sysctl -p After logging on at the prompt type setup-alpine You will be asked a series of questions . I have listed my selection. Keyboard Layout : [us] Keyboard variant : [us] Hostname : [alpinelb] Network : eth0: [dhcp] # Internet connection eth1: [192.168.33.201/24] gateway: [none] password : [abc123] DNS Servers : k8s.lab Timezone :[Singpore] Proxy :[none] ntp: default [chrony] #if it takes long to complete , make sure ipv6 is disabled Mirror :[f] # Detect and add fastest mirror setup user : [no] Which ssh server? [openssh] allow root ssh login: [yes] Allow ssh login : [yes] Which disks would you like to use : [sda] Disk Mode How would you like to use it ? [sys] Erase the above disks and continue? [y] Install Docker on alpine. Ensure community repository is enabled. /etc/apk/repositories #/media/cdrom/apks http://dl-cdn.alpinelinux.org/alpine/v3.16/main http://dl-cdn.alpinelinux.org/alpine/v3.16/community add and update docker apk update apk add docker docker-compose rc-update add docker boot service docker start #restarted VM. # had errors like alpinelb:~# service docker start -v * Executing: /lib/rc/sh/openrc-run.sh /lib/rc/sh/openrc-run.sh /etc/init.d/docker start * Starting Docker Daemon ... * supervise-daemon: fopen `/var/run/supervise-docker.pid': No such file or directory * Detaching to start `/usr/bin/dockerd' # restart resolved the issues. docker pull nginx:1.14 grep docker /var/log/messages | tail -100 /etc/nginx.conf events{} http { server { listen 8080; location /nginx_status{ stub_status; } #return 301 https://$host$request_uri; } } stream { upstream k8s_servers { least_conn; server 192.168.33.201:6443 max_fails=2 fail_timeout=5s; server 192.168.33.202:6443 max_fails=2 fail_timeout=5s; server 192.168.33.203:6443 max_fails=2 fail_timeout=5s; } server { listen 6443; proxy_pass k8s_servers; } server { listen 443; proxy_pass k8s_servers; } } Run nginx docker docker run -d --restart=unless-stopped \\ -p 6443:6443 -p 443:443 \\ -v /etc/nginx.conf:/etc/nginx/nginx.conf \\ nginx:1.14 Docker commands # list images alpinelb:~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE nginx 1.14 295c7be07902 4 years ago 109MB # list running containers alpinelb:~# docker container list CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d1de2693d20c nginx:1.14 \"nginx -g 'daemon of\u2026\" About a minute ago Restarting (1) 46 seconds ago peaceful_lichterman # stop container docker stop d1de2693d20c # check container logs alpinelb:~# docker logs f874545d6662 2023/11/06 02:26:47 [emerg] 1#1: no \"events\" section in configuration nginx: [emerg] no \"events\" section in configuration 2023/11/06 02:26:49 [emerg] 1#1: no \"events\" section in configuration nginx: [emerg] no \"events\" section in configuration","title":"Setup Alpine Load balancer"},{"location":"Document/draft/200-setup-alpine-LB/#setup-alpine-load-balancer","text":"Setup-alpine hostname IP address alpineLB 192.168.33.201/24","title":"Setup Alpine Load balancer"},{"location":"Document/draft/200-setup-alpine-LB/#install-alpine","text":"","title":"Install alpine"},{"location":"Document/draft/200-setup-alpine-LB/#key-information","text":"Alpine Default login login : root password : blank","title":"Key information"},{"location":"Document/draft/200-setup-alpine-LB/#hyper-v-configuration-for-reference","text":"","title":"Hyper-V configuration for reference"},{"location":"Document/draft/200-setup-alpine-LB/#alpine-install-iso-first-boot","text":"","title":"Alpine install ISO first boot"},{"location":"Document/draft/200-setup-alpine-LB/#disable-ipv6-on-alpine","text":"In my setup IPv6 was not workinging if you have issues with IPv6, do disable before proceeding. Edit the /etc/sysctl.conf vi /etc/sysctl.conf # Manualy type in the following # press [i] to be in insert /edit mode net.ipv6.conf.all.disable_ipv6 = 1 # to save and exit following key press # [esc] :x! [enter] # reload the configuration sysctl -p After logging on at the prompt type setup-alpine You will be asked a series of questions . I have listed my selection. Keyboard Layout : [us] Keyboard variant : [us] Hostname : [alpinelb] Network : eth0: [dhcp] # Internet connection eth1: [192.168.33.201/24] gateway: [none] password : [abc123] DNS Servers : k8s.lab Timezone :[Singpore] Proxy :[none] ntp: default [chrony] #if it takes long to complete , make sure ipv6 is disabled Mirror :[f] # Detect and add fastest mirror setup user : [no] Which ssh server? [openssh] allow root ssh login: [yes] Allow ssh login : [yes] Which disks would you like to use : [sda] Disk Mode How would you like to use it ? [sys] Erase the above disks and continue? [y]","title":"Disable IPv6 on Alpine"},{"location":"Document/draft/200-setup-alpine-LB/#install-docker-on-alpine","text":"Ensure community repository is enabled. /etc/apk/repositories #/media/cdrom/apks http://dl-cdn.alpinelinux.org/alpine/v3.16/main http://dl-cdn.alpinelinux.org/alpine/v3.16/community","title":"Install Docker on alpine."},{"location":"Document/draft/200-setup-alpine-LB/#add-and-update-docker","text":"apk update apk add docker docker-compose rc-update add docker boot service docker start #restarted VM. # had errors like alpinelb:~# service docker start -v * Executing: /lib/rc/sh/openrc-run.sh /lib/rc/sh/openrc-run.sh /etc/init.d/docker start * Starting Docker Daemon ... * supervise-daemon: fopen `/var/run/supervise-docker.pid': No such file or directory * Detaching to start `/usr/bin/dockerd' # restart resolved the issues. docker pull nginx:1.14 grep docker /var/log/messages | tail -100 /etc/nginx.conf events{} http { server { listen 8080; location /nginx_status{ stub_status; } #return 301 https://$host$request_uri; } } stream { upstream k8s_servers { least_conn; server 192.168.33.201:6443 max_fails=2 fail_timeout=5s; server 192.168.33.202:6443 max_fails=2 fail_timeout=5s; server 192.168.33.203:6443 max_fails=2 fail_timeout=5s; } server { listen 6443; proxy_pass k8s_servers; } server { listen 443; proxy_pass k8s_servers; } } Run nginx docker docker run -d --restart=unless-stopped \\ -p 6443:6443 -p 443:443 \\ -v /etc/nginx.conf:/etc/nginx/nginx.conf \\ nginx:1.14","title":"add and update docker"},{"location":"Document/draft/200-setup-alpine-LB/#docker-commands","text":"# list images alpinelb:~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE nginx 1.14 295c7be07902 4 years ago 109MB # list running containers alpinelb:~# docker container list CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d1de2693d20c nginx:1.14 \"nginx -g 'daemon of\u2026\" About a minute ago Restarting (1) 46 seconds ago peaceful_lichterman # stop container docker stop d1de2693d20c # check container logs alpinelb:~# docker logs f874545d6662 2023/11/06 02:26:47 [emerg] 1#1: no \"events\" section in configuration nginx: [emerg] no \"events\" section in configuration 2023/11/06 02:26:49 [emerg] 1#1: no \"events\" section in configuration nginx: [emerg] no \"events\" section in configuration","title":"Docker commands"},{"location":"Document/draft/200-setup-alpine-LB/#_1","text":"","title":""},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/","text":"alpine1 setup and configuration. Configure PXE configurations Working folder. The files for PXE will be stored in the folder tftp in srv . mkdir -p /srv/tftp In this setup syslinux was used to serve the PXE menu. Boot files. When booting a Server with Linux, there are 2 files required. vmlinuz and initrd at times the version is part of the name depending on Linux flavors In this example boot files are retrieved from ubuntu-20.04.6-live-server-amd64.iso Step 1 Download and Mount the ISO. # lets host the ISO in the folder /iso mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso # Create mount folder mkdir -p /srv/isoubuntu # mount the ISO to view contents. mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu # list content to validate ls /srv/isoubuntu Step 2 Copy boot files from /srv/isoubuntu #create ubuntu folder to store the boot files. # this way we can have boot files for multple distros if required. mkdir -p /srv/tftp/ubuntu/casper # copy files cp /srv/isoubuntu/casper/vmlinuz /srv/tftp/ubuntu/casper cp /srv/isoubuntu/casper/initrd /srv/tftp/ubuntu/casper PXE boot files. Apart from the Linux boot files, we also need to have the boot files for pxelinux to function. Syslinux requires the following files Backgroud BIOS is for older Computers. The newer computers work with EFI. This was confusing initialy as the SYSLINUX files actually have versions specific to BIOS , EFI32 EFI64. In HyperV when you create a VM you are given a choice of Generation 1 or Generation 2. If you selected Generation 1 then you need to use the BIOS version. In this lab Generation 2 was selected. the BIOS version is stated here to provide this fact. This could have saved me a lot of time. BIOS Core files pxelinux.0 ldlinux.c32 Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 EFI64 Core files ldlinux.e64 syslinux.efi Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 Where to get these files? Step 1 Download syslinux SYSLINUX ver 6.03 from the official site To extract the relevant files can be quite an effort to explain, I have compiled the required files. syslinux-6.04-pre1-PXE-specific.tar Boot Menu configuration Once we have the files in place, we can now prepare the Syslinux Boot Menu. Update pxelinux.cfg/default vi /srv/tftp/efi64/pxelinux.cfg/default DEFAULT ubuntu TIMEOUT 50 UI vesamenu.c32 MENU RESOLUTION 1024 768 MENU BACKGROUND splash/pine-green-splash.png MENU TITLE PXE Boot Menu #working ISO downloaded and installer started and user-data found. 12 November 2023s LABEL ubuntu MENU LABEL ubuntu KERNEL http://192.168.33.250/tftp/fai/ubuntu/casper/vmlinuz INITRD http://192.168.33.250/tftp/fai/ubuntu/casper/initrd append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso cloud-config-url=/dev/null ip=dhcp fsck.mode=skip --- #working append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/fai/autoinstalldata/ ip=dhcp fsck.mode=skip --- Scratch LABEL ubuntu MENU LABEL ubuntu KERNEL http://192.168.33.250/tftp/fai/ubuntu/casper/vmlinuz INITRD http://192.168.33.250/tftp/fai/ubuntu/casper/initrd # pass user-data in append #working append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/fai/autoinstalldata/ ip=dhcp fsck.mode=skip --- #scratch APPEND root=/dev/ram0 ramdisk_size=1500000 ip=dhcp url=http://10.10.2.1/ubuntu-20.10-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://10.10.2.1/ubuntu-server-20.10/ APPEND root=/dev/ram0 ramdisk_size=1500000 url=http://192.168.33.250/fai/ubuntu/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/fai/autoinstalldata/ append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/ks/ cloud-config-url=/dev/null ip=dhcp fsck.mode=skip ---","title":"alpine1 setup and configuration."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#alpine1-setup-and-configuration","text":"","title":"alpine1 setup and configuration."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#configure-pxe-configurations","text":"Working folder. The files for PXE will be stored in the folder tftp in srv . mkdir -p /srv/tftp In this setup syslinux was used to serve the PXE menu.","title":"Configure PXE configurations"},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#boot-files","text":"When booting a Server with Linux, there are 2 files required. vmlinuz and initrd at times the version is part of the name depending on Linux flavors In this example boot files are retrieved from ubuntu-20.04.6-live-server-amd64.iso Step 1 Download and Mount the ISO. # lets host the ISO in the folder /iso mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso # Create mount folder mkdir -p /srv/isoubuntu # mount the ISO to view contents. mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu # list content to validate ls /srv/isoubuntu Step 2 Copy boot files from /srv/isoubuntu #create ubuntu folder to store the boot files. # this way we can have boot files for multple distros if required. mkdir -p /srv/tftp/ubuntu/casper # copy files cp /srv/isoubuntu/casper/vmlinuz /srv/tftp/ubuntu/casper cp /srv/isoubuntu/casper/initrd /srv/tftp/ubuntu/casper","title":"Boot files."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#pxe-boot-files","text":"Apart from the Linux boot files, we also need to have the boot files for pxelinux to function.","title":"PXE boot files."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#syslinux-requires-the-following-files","text":"Backgroud BIOS is for older Computers. The newer computers work with EFI. This was confusing initialy as the SYSLINUX files actually have versions specific to BIOS , EFI32 EFI64. In HyperV when you create a VM you are given a choice of Generation 1 or Generation 2. If you selected Generation 1 then you need to use the BIOS version. In this lab Generation 2 was selected. the BIOS version is stated here to provide this fact. This could have saved me a lot of time. BIOS Core files pxelinux.0 ldlinux.c32 Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 EFI64 Core files ldlinux.e64 syslinux.efi Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32","title":"Syslinux requires the following files"},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#where-to-get-these-files","text":"Step 1 Download syslinux SYSLINUX ver 6.03 from the official site To extract the relevant files can be quite an effort to explain, I have compiled the required files. syslinux-6.04-pre1-PXE-specific.tar","title":"Where to get these files?"},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#boot-menu-configuration","text":"Once we have the files in place, we can now prepare the Syslinux Boot Menu.","title":"Boot Menu configuration"},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu%20copy/#update-pxelinuxcfgdefault","text":"vi /srv/tftp/efi64/pxelinux.cfg/default DEFAULT ubuntu TIMEOUT 50 UI vesamenu.c32 MENU RESOLUTION 1024 768 MENU BACKGROUND splash/pine-green-splash.png MENU TITLE PXE Boot Menu #working ISO downloaded and installer started and user-data found. 12 November 2023s LABEL ubuntu MENU LABEL ubuntu KERNEL http://192.168.33.250/tftp/fai/ubuntu/casper/vmlinuz INITRD http://192.168.33.250/tftp/fai/ubuntu/casper/initrd append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso cloud-config-url=/dev/null ip=dhcp fsck.mode=skip --- #working append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/fai/autoinstalldata/ ip=dhcp fsck.mode=skip --- Scratch LABEL ubuntu MENU LABEL ubuntu KERNEL http://192.168.33.250/tftp/fai/ubuntu/casper/vmlinuz INITRD http://192.168.33.250/tftp/fai/ubuntu/casper/initrd # pass user-data in append #working append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/fai/autoinstalldata/ ip=dhcp fsck.mode=skip --- #scratch APPEND root=/dev/ram0 ramdisk_size=1500000 ip=dhcp url=http://10.10.2.1/ubuntu-20.10-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://10.10.2.1/ubuntu-server-20.10/ APPEND root=/dev/ram0 ramdisk_size=1500000 url=http://192.168.33.250/fai/ubuntu/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/fai/autoinstalldata/ append url=http://192.168.33.250/ubuntu-iso-mnt/ubuntu-20.04.6-live-server-amd64.iso autoinstall ds=nocloud-net;s=http://192.168.33.250/ks/ cloud-config-url=/dev/null ip=dhcp fsck.mode=skip ---","title":"Update pxelinux.cfg/default"},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu/","text":"alpine1 setup and configuration. Configure PXE configurations Working folder. The files for PXE will be stored in the folder tftp in srv . mkdir -p /srv/tftp In this setup syslinux was used to serve the PXE menu. Boot files. When booting a Server with Linux, there are 2 files required. vmlinuz and initrd at times the version is part of the name depending on Linux flavors In this example boot files are retrieved from ubuntu-20.04.6-live-server-amd64.iso Step 1 Download and Mount the ISO. # lets host the ISO in the folder /iso mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso # Create mount folder mkdir -p /srv/isoubuntu # mount the ISO to view contents. mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu # list content to validate ls /srv/isoubuntu Step 2 Copy boot files from /srv/isoubuntu #create ubuntu folder to store the boot files. # this way we can have boot files for multple distros if required. mkdir -p /srv/tftp/ubuntu/casper # copy files cp /srv/isoubuntu/casper/vmlinuz /srv/tftp/ubuntu/casper cp /srv/isoubuntu/casper/initrd /srv/tftp/ubuntu/casper PXE boot files. Apart from the Linux boot files, we also need to have the boot files for pxelinux to function. Syslinux requires the following files Backgroud BIOS is for older Computers. The newer computers work with EFI. This was confusing initialy as the SYSLINUX files actually have versions specific to BIOS , EFI32 EFI64. In HyperV when you create a VM you are given a choice of Generation 1 or Generation 2. If you selected Generation 1 then you need to use the BIOS version. In this lab Generation 2 was selected. the BIOS version is stated here to provide this fact. This could have saved me a lot of time. BIOS Core files pxelinux.0 ldlinux.c32 Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 EFI64 Core files ldlinux.e64 syslinux.efi Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 Where to get these files? Step 1 Download syslinux SYSLINUX ver 6.03 from the official site To extract the relevant files can be quite an effort to explain, I have compiled the required files. syslinux-6.04-pre1-PXE-specific.tar","title":"alpine1 setup and configuration."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu/#alpine1-setup-and-configuration","text":"","title":"alpine1 setup and configuration."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu/#configure-pxe-configurations","text":"Working folder. The files for PXE will be stored in the folder tftp in srv . mkdir -p /srv/tftp In this setup syslinux was used to serve the PXE menu.","title":"Configure PXE configurations"},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu/#boot-files","text":"When booting a Server with Linux, there are 2 files required. vmlinuz and initrd at times the version is part of the name depending on Linux flavors In this example boot files are retrieved from ubuntu-20.04.6-live-server-amd64.iso Step 1 Download and Mount the ISO. # lets host the ISO in the folder /iso mkdir -p /srv/tftp/iso # Download the ISO wget -P /srv/tftp/iso https://releases.ubuntu.com/20.04.6/ubuntu-20.04.6-live-server-amd64.iso # Create mount folder mkdir -p /srv/isoubuntu # mount the ISO to view contents. mount -o loop,ro -t iso9660 /srv/tftp/iso/ubuntu-20.04.6-live-server-amd64.iso /srv/isoubuntu # list content to validate ls /srv/isoubuntu Step 2 Copy boot files from /srv/isoubuntu #create ubuntu folder to store the boot files. # this way we can have boot files for multple distros if required. mkdir -p /srv/tftp/ubuntu/casper # copy files cp /srv/isoubuntu/casper/vmlinuz /srv/tftp/ubuntu/casper cp /srv/isoubuntu/casper/initrd /srv/tftp/ubuntu/casper","title":"Boot files."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu/#pxe-boot-files","text":"Apart from the Linux boot files, we also need to have the boot files for pxelinux to function.","title":"PXE boot files."},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu/#syslinux-requires-the-following-files","text":"Backgroud BIOS is for older Computers. The newer computers work with EFI. This was confusing initialy as the SYSLINUX files actually have versions specific to BIOS , EFI32 EFI64. In HyperV when you create a VM you are given a choice of Generation 1 or Generation 2. If you selected Generation 1 then you need to use the BIOS version. In this lab Generation 2 was selected. the BIOS version is stated here to provide this fact. This could have saved me a lot of time. BIOS Core files pxelinux.0 ldlinux.c32 Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32 EFI64 Core files ldlinux.e64 syslinux.efi Basic Menu These files are required if you want to have a menu selection. If you don't have multple Boot options to present these files are not needed. menu.c32 libutil.c32 Graphics Menu These files are required if you want to have a menu selection but with better graphics where you can have png file as a backgroud. If you don't have multple Boot options to present these files are not needed. vesamenu.c32 libcom32.c32","title":"Syslinux requires the following files"},{"location":"Document/draft/9108-alpine1-setup-pxe-bootmenu/#where-to-get-these-files","text":"Step 1 Download syslinux SYSLINUX ver 6.03 from the official site To extract the relevant files can be quite an effort to explain, I have compiled the required files. syslinux-6.04-pre1-PXE-specific.tar","title":"Where to get these files?"},{"location":"Document/draft/999-alpine1-DHCP-set-hostname/","text":"alpine1 setup and configuration. update DHCP options to provide PXE boot information to clients. The initial DHCP was to provide IP addresses to remote clients. As we now want to provide the scope options for the tftp servers with the boot file location, lets make the following changes. Update the dhcpd.conf as follows. vi /etc/dhcp/dhcpd.conf subnet 192.168.100.0 netmask 255.255.255.0 { range 192.168.100.50 192.168.100.100; option routers 192.168.100.1; option domain-name-servers 192.168.100.1; option time-servers 192.168.100.1; option ntp-servers 192.168.100.1; # next-server 192.168.100.1; # this is typically if the tftp is on another server. if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00000\" { filename \"bios/pxelinux.0\"; } if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00007\" { filename \"efi64/syslinux.efi\"; } #assign IP based on MAC address host alpine1 { hardware ethernet 00:15:5D:00:8A:4D; fixed-address 192.168.100.1; option host-name \"alpine1\"; } host loadbalancer { hardware ethernet 00:15:5D:00:8A:4F; fixed-address 192.168.100.201; option host-name \"loadbalancer\"; } host master1 { hardware ethernet 00:15:5D:00:8A:50; fixed-address 192.168.100.202; option host-name \"master1\"; } host master2 { hardware ethernet 00:15:5D:00:8A:52; fixed-address 192.168.100.203; option host-name \"master2\"; } host master3 { hardware ethernet 00:15:5D:00:8A:53; fixed-address 192.168.100.204; option host-name \"master3\"; } host worker1 { hardware ethernet 00:15:5D:00:8A:54; fixed-address 192.168.100.205; option host-name \"worker1\"; } host worker2 { hardware ethernet 00:15:5D:00:8A:55; fixed-address 192.168.100.206; option host-name \"worker2\"; } host worker3 { hardware ethernet 00:15:5D:00:8A:56; fixed-address 192.168.100.207; option host-name \"worker3\"; } host xsinglenode { hardware ethernet 00:15:5D:00:8A:51; fixed-address 192.168.100.199; option host-name \"xsinglenode\"; } } Restart the dhcp service. rc-service dhcpd restart Vaidation At this stage we cannot perform test to validate if this works. This is because we have not setup the files for the boot process. Lets defer the test after the boot files have been setup. alpine1 IN A 192.168.100.1 k8s-ha-cluster IN A 192.168.100.201 loadbalancer IN A 192.168.100.201 master1 IN A 192.168.100.202 master2 IN A 192.168.100.203 master3 IN A 192.168.100.204 worker1 IN A 192.168.100.205 worker2 IN A 192.168.100.206 worker3 IN A 192.168.100.207","title":"alpine1 setup and configuration."},{"location":"Document/draft/999-alpine1-DHCP-set-hostname/#alpine1-setup-and-configuration","text":"","title":"alpine1 setup and configuration."},{"location":"Document/draft/999-alpine1-DHCP-set-hostname/#update-dhcp-options-to-provide-pxe-boot-information-to-clients","text":"The initial DHCP was to provide IP addresses to remote clients. As we now want to provide the scope options for the tftp servers with the boot file location, lets make the following changes. Update the dhcpd.conf as follows. vi /etc/dhcp/dhcpd.conf subnet 192.168.100.0 netmask 255.255.255.0 { range 192.168.100.50 192.168.100.100; option routers 192.168.100.1; option domain-name-servers 192.168.100.1; option time-servers 192.168.100.1; option ntp-servers 192.168.100.1; # next-server 192.168.100.1; # this is typically if the tftp is on another server. if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00000\" { filename \"bios/pxelinux.0\"; } if substring(option vendor-class-identifier, 0, 20) = \"PXEClient:Arch:00007\" { filename \"efi64/syslinux.efi\"; } #assign IP based on MAC address host alpine1 { hardware ethernet 00:15:5D:00:8A:4D; fixed-address 192.168.100.1; option host-name \"alpine1\"; } host loadbalancer { hardware ethernet 00:15:5D:00:8A:4F; fixed-address 192.168.100.201; option host-name \"loadbalancer\"; } host master1 { hardware ethernet 00:15:5D:00:8A:50; fixed-address 192.168.100.202; option host-name \"master1\"; } host master2 { hardware ethernet 00:15:5D:00:8A:52; fixed-address 192.168.100.203; option host-name \"master2\"; } host master3 { hardware ethernet 00:15:5D:00:8A:53; fixed-address 192.168.100.204; option host-name \"master3\"; } host worker1 { hardware ethernet 00:15:5D:00:8A:54; fixed-address 192.168.100.205; option host-name \"worker1\"; } host worker2 { hardware ethernet 00:15:5D:00:8A:55; fixed-address 192.168.100.206; option host-name \"worker2\"; } host worker3 { hardware ethernet 00:15:5D:00:8A:56; fixed-address 192.168.100.207; option host-name \"worker3\"; } host xsinglenode { hardware ethernet 00:15:5D:00:8A:51; fixed-address 192.168.100.199; option host-name \"xsinglenode\"; } } Restart the dhcp service. rc-service dhcpd restart Vaidation At this stage we cannot perform test to validate if this works. This is because we have not setup the files for the boot process. Lets defer the test after the boot files have been setup. alpine1 IN A 192.168.100.1 k8s-ha-cluster IN A 192.168.100.201 loadbalancer IN A 192.168.100.201 master1 IN A 192.168.100.202 master2 IN A 192.168.100.203 master3 IN A 192.168.100.204 worker1 IN A 192.168.100.205 worker2 IN A 192.168.100.206 worker3 IN A 192.168.100.207","title":"update DHCP options to provide PXE boot information to clients."},{"location":"Document/draft/argo-cd/","text":"kubectl create namespace argocd kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml","title":"Argo cd"},{"location":"Document/draft/kubernetes-upgrade/","text":"use bash console install yq choco install yq jsonnet https://github.com/google/go-jsonnet/releases jq https://jqlang.github.io/jq/download/ choco install jq","title":"Kubernetes upgrade"},{"location":"Document/draft/kubernetes-upgrade/#_1","text":"install yq choco install yq","title":""},{"location":"Document/draft/kubernetes-upgrade/#_2","text":"jsonnet https://github.com/google/go-jsonnet/releases","title":""},{"location":"Document/draft/kubernetes-upgrade/#jq","text":"https://jqlang.github.io/jq/download/ choco install jq","title":"jq"},{"location":"Document/draft/ad-login/001-k3s-setup/","text":"In order for the k3s to recoginize the autenthication token, the k3s service needs to be started with the OIDC issuer configuation curl -sfL https://get.k3s.io | \\ INSTALL_K3S_VERSION=\"v1.24.6+k3s1\" \\ --write-kubeconfig-mode 644 \\ --tls-san \"singleubuntu\" \\ --disable \"traefik\" \\ --kube-apiserver-arg \"oidc-issuer-url=\"https://sts.windows.net/a01c77f7-d822-4d88-88fd-9a738c46e3ab\" \\ --kube-apiserver-arg \"oidc-client-id=\"spn:12138e8b-b64f-4bb3-b9f3-a944f24f0c7d\" \\ --kube-apiserver-arg \"oidc-username-claim=upn\" \\ --kube-apiserver-arg \"oidc-groups-claim=groups\" \\ --kube-apiserver-arg \"oidc-username-prefix=aad:\" \\ --kube-apiserver-arg \"oidc-groups-prefix=aad:\" \\ --kube-apiserver-arg \"audit-log-path=/var/log/kubernetes/audit/audit.log\" \\ --kube-apiserver-arg \"audit-policy-file=/var/lib/rancher/k3s/server/manifests/audit.yaml\" \\ --kube-apiserver-arg \"audit-log-maxsize=100\" \\ --kube-apiserver-arg \"audit-log-maxbackup=30\" --kube-apiserver-arg \"oidc-ca-file=/var/lib/rancher/k3s/server/tls/server-ca.crt\" curl -sfL https://get.k3s.io | \\ INSTALL_K3S_VERSION=\"v1.24.6+k3s1\" \\ sh -s - server \\ --write-kubeconfig-mode 644 \\ --tls-san \"{{INSERT LOAD BALANCER VM HOSTNAME HERE}}\" \\ --cluster-init \\ --node-taint CriticalAddonsOnly=true:NoExecute \\ --disable \"traefik\" \\ --disable \"local-storage\" \\ --disable \"servicelb\" \\ --kube-apiserver-arg \"oidc-issuer-url=https://sts.windows.net/41875f2b-33e8-4670-92a8-f643afbb243a/\" \\ --kube-apiserver-arg \"oidc-client-id=spn:bf07ce73-75d7-4a5f-8a27-7975e258b674\" \\ --kube-apiserver-arg \"oidc-username-claim=upn\" \\ --kube-apiserver-arg \"oidc-groups-claim=groups\" \\ --kube-apiserver-arg \"oidc-username-prefix=aad:\" \\ --kube-apiserver-arg \"oidc-groups-prefix=aad:\" \\ --kube-apiserver-arg \"audit-log-path=/var/log/kubernetes/audit/audit.log\" \\ --kube-apiserver-arg \"audit-policy-file=/var/lib/rancher/k3s/server/manifests/audit.yaml\" \\ --kube-apiserver-arg \"audit-log-maxsize=100\" \\ --kube-apiserver-arg \"audit-log-maxbackup=30\" curl -sfL https://get.k3s.io | \\ INSTALL_K3S_VERSION=\"v1.23.5+k3s1\" \\ sh -s - \\ --write-kubeconfig-mode 644 \\ --tls-san \"x9149.prd.it29m.skf.io\" \\ --disable \"traefik\" \\ --kube-apiserver-arg \"oidc-issuer-url=https://sts.windows.net/41875f2b-33e8-4670-92a8-f643afbb243a/\" \\ --kube-apiserver-arg \"oidc-client-id=spn:bf07ce73-75d7-4a5f-8a27-7975e258b674\" \\ --kube-apiserver-arg \"oidc-username-claim=upn\" \\ --kube-apiserver-arg \"oidc-groups-claim=groups\" \\ --kube-apiserver-arg \"oidc-username-prefix=aad:\" \\ --kube-apiserver-arg \"oidc-groups-prefix=aad:\" --oidc-ca-file=/var/lib/rancher/k3s/serverserver-ca.crt Troubleshooting Service is loaded from /etc/systemd/system/k3s.service journalctl -u k3s | grep -i -E 'OIDC|OpenID|authentication' journalctl -u k3s -n 100 sudo systemctl restart systemd-journald kubectl config set-cluster ctx-k3s-single-lab-02 --insecure-skip-tls-verify=true k3s-single-lab-02 --insecure-skip-tls-verify=true kubectl config set-cluster k3s-single-lab-02 --insecure-skip-tls-verify=true","title":"001 k3s setup"},{"location":"Document/draft/ad-login/001-k3s-setup/#troubleshooting","text":"Service is loaded from /etc/systemd/system/k3s.service journalctl -u k3s | grep -i -E 'OIDC|OpenID|authentication' journalctl -u k3s -n 100 sudo systemctl restart systemd-journald kubectl config set-cluster ctx-k3s-single-lab-02 --insecure-skip-tls-verify=true k3s-single-lab-02 --insecure-skip-tls-verify=true kubectl config set-cluster k3s-single-lab-02 --insecure-skip-tls-verify=true","title":"Troubleshooting"},{"location":"Document/draft/ad-login/azure-ad-setup/","text":"App Registration application / Client ID tenant ID ObjectID ( not used much) API permission - MS Graph - - openid,email, group etc permission for application to access/ Client secrets API permissions MS Graph> Delegated > under OpenID Permission Add email and profile under openid Authentication Advanced settings >> change to yes Enterprise application ( list of SP) by tenant Service Principals Scope , consent , token name :kubectl-ent-app-ad-login **** Application (client) ID: d4b86a76-3c21-464a-ae67-8b15eaf6ee87 users: - name: azure-add-user user: exec: apiVersion: client.authentication.k8s.io/v1beta1 args: - get-token - --environment - AzurePublicCloud - --server-id * ( for SSO) - 9f409b8b-ef4c-4457-bb1b-1f7bdb9cfdf5 - --client-id **** ( for kubectl RBAC) - c7fbbe69-7a9c-472c-a0e5-8e1665515720 - --tenant-id - a01c77f7-d822-4d88-88fd-9a738c46e3ab - --legacy command: kubelogin env: null interactiveMode: IfAvailable provideClusterInfo: false kubectl config set-credentials \"azure-add-user\" \\ --exec-api-version=client.authentication.k8s.io/v1beta1 \\ --exec-command=kubelogin \\ --exec-arg=get-token \\ --exec-arg=--environment \\ --exec-arg=AzurePublicCloud \\ --exec-arg=--server-id \\ --exec-arg=9f409b8b-ef4c-4457-bb1b-1f7bdb9cfdf5 \\ --exec-arg=--client-id \\ --exec-arg=c7fbbe69-7a9c-472c-a0e5-8e1665515720 \\ --exec-arg=--tenant-id \\ --exec-arg=a01c77f7-d822-4d88-88fd-9a738c46e3ab\\ --exec-arg=--legacy kubelogin --client-id c7fbbe69-7a9c-472c-a0e5-8e1665515720 --tenant-id a01c77f7-d822-4d88-88fd-9a738c46e3ab --server-id 9f409b8b-ef4c-4457-bb1b-1f7bdb9cfdf5 --login devicecode Request Id: bb97976a-a7b1-4bb6-9ccb-27074cc76102 Correlation Id: 55c40d37-3321-4ed2-a00f-75364b8e3792 Timestamp: 2023-12-24T13:06:25Z Message: AADSTS650057: Invalid resource. The client has requested access to a resource which is not listed in the requested permissions in the client's application registration. Client app ID: d4b86a76-3c21-464a-ae67-8b15eaf6ee87(kubectl-ent-app-ad-login). Resource value from request: ccf2ea19-40ae-400a-a97a-928ad0e8614c. Resource app ID: ccf2ea19-40ae-400a-a97a-928ad0e8614c. List of valid resources from app registration: 00000003-0000-0000-c000-000000000000.","title":"Azure ad setup"},{"location":"Document/draft/ad-login/azure-ad-setup/#_1","text":"API permissions MS Graph> Delegated > under OpenID Permission Add email and profile under openid Authentication Advanced settings >> change to yes","title":""},{"location":"Document/draft/ad-login/azure-ad-setup/#_2","text":"Enterprise application ( list of SP) by tenant Service Principals Scope , consent , token name :kubectl-ent-app-ad-login **** Application (client) ID: d4b86a76-3c21-464a-ae67-8b15eaf6ee87 users: - name: azure-add-user user: exec: apiVersion: client.authentication.k8s.io/v1beta1 args: - get-token - --environment - AzurePublicCloud - --server-id * ( for SSO) - 9f409b8b-ef4c-4457-bb1b-1f7bdb9cfdf5 - --client-id **** ( for kubectl RBAC) - c7fbbe69-7a9c-472c-a0e5-8e1665515720 - --tenant-id - a01c77f7-d822-4d88-88fd-9a738c46e3ab - --legacy command: kubelogin env: null interactiveMode: IfAvailable provideClusterInfo: false kubectl config set-credentials \"azure-add-user\" \\ --exec-api-version=client.authentication.k8s.io/v1beta1 \\ --exec-command=kubelogin \\ --exec-arg=get-token \\ --exec-arg=--environment \\ --exec-arg=AzurePublicCloud \\ --exec-arg=--server-id \\ --exec-arg=9f409b8b-ef4c-4457-bb1b-1f7bdb9cfdf5 \\ --exec-arg=--client-id \\ --exec-arg=c7fbbe69-7a9c-472c-a0e5-8e1665515720 \\ --exec-arg=--tenant-id \\ --exec-arg=a01c77f7-d822-4d88-88fd-9a738c46e3ab\\ --exec-arg=--legacy kubelogin --client-id c7fbbe69-7a9c-472c-a0e5-8e1665515720 --tenant-id a01c77f7-d822-4d88-88fd-9a738c46e3ab --server-id 9f409b8b-ef4c-4457-bb1b-1f7bdb9cfdf5 --login devicecode Request Id: bb97976a-a7b1-4bb6-9ccb-27074cc76102 Correlation Id: 55c40d37-3321-4ed2-a00f-75364b8e3792 Timestamp: 2023-12-24T13:06:25Z Message: AADSTS650057: Invalid resource. The client has requested access to a resource which is not listed in the requested permissions in the client's application registration. Client app ID: d4b86a76-3c21-464a-ae67-8b15eaf6ee87(kubectl-ent-app-ad-login). Resource value from request: ccf2ea19-40ae-400a-a97a-928ad0e8614c. Resource app ID: ccf2ea19-40ae-400a-a97a-928ad0e8614c. List of valid resources from app registration: 00000003-0000-0000-c000-000000000000.","title":""},{"location":"Document/draft/ad-login/entra-app-registration-aks-cli-kubectl/","text":"https://azure.github.io/kubelogin/topics/k8s-oidc-aad.html","title":"Entra app registration aks cli kubectl"},{"location":"Document/draft/ad-login/kubectl-kubelogin/","text":"install Kubelogin # windows choco install kubelogin # Linux https://lightrun.com/answers/azure-azure-cli-install-azure-cli-on-alpine-linux use az cli. apk add py3-pip apk add gcc musl-dev python3-dev libffi-dev openssl-dev cargo make pip install --upgrade pip pip install azure-cli #kubectl and kubelogin installed via az aks install-cli ## had issues installing on alpine linux. curl -Lo kubelogin https://github.com/Azure/kubelogin/releases/download/v0.0.34/kubelogin.zip unzip kubelogin.zip copy kubelogin to /usr/local/bin reset the tmp to 2GB alpine1:/# df -h Filesystem Size Used Available Use% Mounted on devtmpfs 10.0M 0 10.0M 0% /dev shm 452.2M 0 452.2M 0% /dev/shm /dev/sda3 47.7G 5.6G 39.7G 12% / tmpfs 180.9M 332.0K 180.5M 0% /run /dev/sda1 511.0M 280.0K 510.7M 0% /boot/efi tmpfs 452.2M 0 452.2M 0% /tmp cgroup_root 10.0M 0 10.0M 0% /sys/fs/cgroup alpine1:/# vi /etc/fstab alpine1:/# mount -o remount,size=2G,noexec,nosuid,nodev,noatime /tmp alpine1:/# df -h Filesystem Size Used Available Use% Mounted on devtmpfs 10.0M 0 10.0M 0% /dev shm 452.2M 0 452.2M 0% /dev/shm /dev/sda3 47.7G 5.6G 39.7G 12% / tmpfs 180.9M 332.0K 180.5M 0% /run /dev/sda1 511.0M 280.0K 510.7M 0% /boot/efi tmpfs 2.0G 0 2.0G 0% /tmp cgroup_root 10.0M 0 10.0M 0% /sys/fs/cgroup","title":"Kubectl kubelogin"},{"location":"Document/draft/ad-login/kubectl-login-ad/","text":"sre@sureshsolomonyahoo.onmicrosoft.com Spider9257 dev@sureshsolomonyahoo.onmicrosoft.com Spider9257 appdev sredevgrp@sureshsolomonyahoo.onmicrosoft.com Spider9257 opssre sregrp@sureshsolomonyahoo.onmicrosoft.com Spider9257 https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/authentication-permissions-and-global-configuration/authentication-config/configure-azure-ad https://documentation.breadnet.co.uk/kubernetes/k3s/oidc-azure-ad/?utm_source=reddit&utm_medium=post&utm_campaign=k3s-oidc#create-app-registration add AD as authentication provider/","title":"Kubectl login ad"},{"location":"Document/draft/ad-login/kubectl-login-ad/#add-ad-as-authentication-provider","text":"","title":"add AD as authentication provider/"},{"location":"Document/draft/ad-login/test-ad-authentication/","text":"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/authorize ?client_id={client_id} &response_type=code &redirect_uri={redirect_uri} &response_mode=query &scope={scopes} https://login.microsoftonline.com/a01c77f7-d822-4d88-88fd-9a738c46e3ab/oauth2/v2.0/authorize ?client_id=9f409b8b-ef4c-4457-bb1b-1f7bdb9cfdf5 &response_type=code &redirect_uri=https://jwt.ms/ &scope=openid User.Read Group.Read.All https://login.microsoftonline.com/a01c77f7-d822-4d88-88fd-9a738c46e3ab/oauth2/v2.0/token ?client_id=1183f353-92b5-493d-97cd-9749773dd79b &scope=openid &grant_type=client_credentials to list all the openid config values for the above options https://login.microsoftonline.com/a01c77f7-d822-4d88-88fd-9a738c46e3ab/.well-known/openid-configuration Key app registration configuration required App id/ client id Tenant id authentication add redirect URL check Access tokens (used for implicit flows) ID tokens (used for implicit and hybrid flows) Allow public client flows > yes","title":"Test ad authentication"},{"location":"Document/draft/ad-login/test-ad-authentication/#key-app-registration-configuration-required","text":"App id/ client id Tenant id authentication add redirect URL check Access tokens (used for implicit flows) ID tokens (used for implicit and hybrid flows) Allow public client flows > yes","title":"Key app registration configuration required"},{"location":"Document/draft/ad-login/windows-install-az-cli/","text":"$ProgressPreference = 'SilentlyContinue'; Invoke-WebRequest -Uri https://aka.ms/installazurecliwindows -OutFile .\\AzureCLI.msi; Start-Process msiexec.exe -Wait -ArgumentList '/I AzureCLI.msi /quiet'; Remove-Item .\\AzureCLI.msi","title":"Windows install az cli"},{"location":"Document/k3s-deployment/200-Ansible-setup/","text":"","title":"200 Ansible setup"},{"location":"Document/k3s-deployment/201-k3s-setup/","text":"","title":"201 k3s setup"}]}